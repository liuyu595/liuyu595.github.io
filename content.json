[{"title":"ES6Tab选项卡、轮播图","date":"2017-03-15T14:27:07.000Z","path":"2017/03/15/ES6Tab选项卡、轮播图/","text":"摘要：ES6 面向对象编程——选项卡、轮播图 正文： es6面向对象——选项卡、轮播直接荔枝（今天心情不错，换个果子） 样式部分 1234567.on&#123;background:#f60;color:#fff&#125;.box div&#123;width:200px;height:200px;border:1px red solid;display:none;&#125; heml部分12345678910111213141516&lt;div id=\"box\" class=\"box\"&gt;&lt;input class=\"on\" type=\"button\" value=\"aaa\"&gt;&lt;input type=\"button\" value=\"bbb\"&gt;&lt;input type=\"button\" value=\"ccc\"&gt;&lt;div style=\"display: block\"&gt;111&lt;/div&gt;&lt;div&gt;222&lt;/div&gt;&lt;div&gt;333&lt;/div&gt;&lt;/div&gt;&lt;div id=\"box2\" class=\"box\"&gt;&lt;input class=\"on\" type=\"button\" value=\"aaa\"&gt;&lt;input type=\"button\" value=\"bbb\"&gt;&lt;input type=\"button\" value=\"ccc\"&gt;&lt;div style=\"display: block\"&gt;111&lt;/div&gt;&lt;div&gt;222&lt;/div&gt;&lt;div&gt;333&lt;/div&gt;&lt;/div&gt; js部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Tab&#123;constructor(id)&#123;this.oBox=document.getElementById(id);this.aBtn=this.oBox.getElementsByTagName('input');this.aDiv=this.oBox.getElementsByTagName('div');this.iNow=0;this.init();&#125;init()&#123;for(let i=0; i&lt;this.aBtn.length; i++)&#123;this.aBtn[i].onclick=function()&#123;// alert(i);// alert(this);this.hide();this.show(i);&#125;.bind(this); //bind矫正this指向&#125;&#125;hide()&#123;for(let i=0;i&lt;this.aBtn.length;i++)&#123;this.aBtn[i].className=\"\";this.aDiv[i].style.display='none';&#125;&#125;show(index)&#123;this.aBtn[index].className=\"on\";this.aDiv[index].style.display='block';&#125;&#125;//继承class AutoTab extends Tab&#123;//constructor(id)&#123;super(id);//alert(111);//setInterval(this.next,1000); this 指向objsetInterval(this.next.bind(this),1000);&#125;next()&#123;this.iNow++;if(this.iNow==this.aBtn.length)this.iNow=0;this.hide();this.show(this.iNow);&#125;&#125;window.onload=function()&#123;new Tab('box');var at=new AutoTab(\"box2\");&#125;","tags":[{"name":"ES6语法","slug":"ES6语法","permalink":"https://liuyu595.github.io/tags/ES6语法/"}]},{"title":"ES6入门笔记（三）","date":"2017-03-14T06:17:47.000Z","path":"2017/03/14/ES6入门笔记（三）“/","text":"摘要：箭头函数、面向对象、继承。 正文： 箭头函数 =&gt;不多说直接一个栗子：12345678window.onload=()=&gt;&#123;var oBox=document.getElementById(\"box\");oBox.onclivk=()=&gt;&#123;//alert(this);//这时这里的this指的是window,所有没有办法this.styleoBox.style.background=\"red\";&#125;;&#125;; 1&lt;div id=\"box\"&gt;&lt;/div&gt; 注意：1、 this的问题,指向window；2、箭头函数中arguments,不能使用。 对象：es6对象作了简化单体模式直接简单粗暴上举板栗： 12345678910111213var name='abb';var age=111;var preson=&#123;name,age,showName()&#123;return this.name;&#125;,showName()&#123;return this.age;&#125;&#125;;alert( preson.showName() ); 面向对象es6之前123456789101112function Person(name,age)&#123;this.name=name;this.age=age;&#125;Person.prototype.showName=function()&#123;return this.name;&#125;;Person.prototype.showName=function()&#123;return this.name;&#125;;var p1=new Person(\"abc\",101);alert(p1.showName()); 上面这样写不是真的面向对象，这里的这个东西又是类又是构造函数。es6在面向对象上面做了一个彻底的区分，什么是构造函数？构造函数简单的说就是生成实例以后，自己就执行的函数。1234567891011121314151617来吧～！锯割栗子：```javascriptclass Person&#123; //类constructor(name,age)&#123;this.name=name;this.age=age;&#125;showName()&#123;return this.name;&#125;showAge()&#123;return this.age;&#125;&#125; 函数给默认值1234function move(obj=\"对象必须要填写\"，json=&#123;&#125;)&#123;console.log(options);&#125;move(); 继承之前的继承，来再锯割栗子：1234567function Worker(name,age)&#123;Person.apply(this,arguments);&#125;Worker.prototype=new Person();var w1=new Person('ddd',20);alert(p1.showName());//之前的继承模式：子类.prptotype=new 父类（）； es6中的继承123456789function Worker(name,age)&#123;Person.apply(this,arguments);&#125;//继承开始class Worker extends Person&#123;&#125;var w1=new Worker('mmm',34);alert(w1.showAge()); //34 es6继承中的super锯割栗子：（今天晚上很暴力的吃了好的坚果）1234567891011121314151617181920212223242526class Person&#123;constructor(name='add',age=0)&#123;this.name=name;this.age=age;&#125;showName()&#123;return this.name;&#125;showAge()&#123;return this.age;&#125; &#125;//继承开始class Worker extends Person&#123;constructor(name,age,job=\"刷马桶\")&#123;//这样写之后，之前的父级的构造函数被覆盖掉了为了不被覆盖掉那么我们就用super.//this.job=job; //definedsuper(name,age);this.job=job&#125;showJob()&#123;return this.job;&#125;&#125;var w1=new Worker('mmm',34); 每天多学一点，明天就少写一行代码～！","tags":[{"name":"ES6语法","slug":"ES6语法","permalink":"https://liuyu595.github.io/tags/ES6语法/"}]},{"title":"hexo之入门后填坑(一)","date":"2017-03-13T01:26:51.000Z","path":"2017/03/13/hexo之入门后填坑（一）/","text":"摘要：本文主要说下markdown的语法，编译器。 正文:对于一个新手小白，真的是一坑到底的节奏了。欲哭无泪跳坑吧～！科普下吧：Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 代码块 +「脚本语言名称全拼」+代码内容+```结束12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 表格语法格式12345| Item | Value | Qty || :-------- | --------:| :--: || Computer | 1600 USD | 5 || Phone | 12 USD | 12 || Pipe | 1 USD | 234 | ``` markdown编译器： 推荐 sublime :轻量级编译器功能强大，不具有实时显示编辑文本功能。不建议新手使用。 推荐 马克飞象 :之前一直用印象笔记去记录代码总结，马克飞象是支持Chrome的同样可以绑定到印象笔记，具备实时编辑文本功能。推荐新手使用。","tags":[{"name":"hexo","slug":"hexo","permalink":"https://liuyu595.github.io/tags/hexo/"}]},{"title":"ES6入门笔记（二）","date":"2017-03-12T06:17:47.000Z","path":"2017/03/12/ES6入门笔记（二）/","text":"摘要： 复制数组————spread、Map、for-of循环 正文： 数组复制 举栗子 12345var arr = [1,2,3];var arr2=arr;arr2.pop();console.log(arr, arr2);//arr2删除最后一个元素时，arr也会受到影响 怎么才能不让我们的arr受到牵连呢？ 再举一栗子—–循环 1234567var arr = [1,2,3];var arr2=[];for(var i=0; i&lt;arr.length; i++)&#123;arr2[i]=arr[i];&#125;console.log(arr, arr2);//arr这时候是不会受到任何影响的；但是这种方法比较繁琐； 下面在举一个板栗吧～！ 12345var arr = [1,2,3];var arr2=Array.from(arr);arr2.pop();console.log(arr, arr2);//这个板栗还是可以的，简单多了； 科普下Array.from( ) es6 新特性中 Array 类多了一个静态方法 from ，这个方法作用是将一个 ArrayLike 对象或者 Iterable 对象转换成一个 Array。所谓 ArrayLike 对象指具有数组某些行为的对象，表现出来的特征就是具有 length 属性。 1234var obj = &#123;\"0\" : 1,length: 1&#125;; 这一类对象不能调用数组所具有的方法(push/forEach/map之类)，最常见的有两种：DOM中的 NodeList 和函数中的 arguments 。在平常开发中，我们经常遇到需要将这两种对象转化为真正数组的场景，一般我们是这么写： 12var args = [].slice.call(arguments);var imgs = [].slice.call(document.querySelectorAll('img')); 现在有了Array.from后我们可以这样写： 123var args = Array.from(arguments);var imgs = Array.from(document.querySelectorAll('img'));//不考虑兼容性的时候我们可以这样写 下面言归正传吧：接着写我们的数组～接着举例子！ 新鲜板栗来了～！好吃不贵1234var arr = [1,2,3];var arr2=[...arr];arr2.pop();//前面的这三个点——“超引用”这么叫吧 123456function show(...args)&#123;args.push(5);console.log(args);&#125;show(1,2,3,4)//完美解决 ##循环 es6新增了一个 for of 循环，那么这个循环的目的：是遍历（迭代、循环）这个对象，表现有点类似for in。但是不能循环json,其真正的目的是循环 map对象的。 来个代码看看吧1234var arr=['apple','banana','orange','pear'];for(var i of arr)&#123;console.log(i);&#125; 注：上述打印出来的结果跟普通的for in 打印出来的结果不一样，for in打印出来是数组的下标，而for of 打印出来却是相对应的水果名字。 Map对象map对象和json相似，也是一种key-value形式，Map对象为了和for of 循环为何而生。 语法123456789101112131415var map =new Map（）；//设置：map.set(name,value);//获取map.set('a','apple');map.set('b','banana');//console.log(map.a);//alert(map.a); undefined//获取map就用get（）方法alert(map.get('a'))//删除delete map.a; //json 删除方法在这里没有效果map.delete('a'); //map的delete方法，可以用的 map和for of结合去用：123456789var map =new Map();map.set('a','apple');map.set('b','banana');map.set('c','orange');map.set('d','pear');for(var [key,value] of map)&#123;console.log(key,value);//[key,value]中两个参数可以是任何字母&#125; 1234for(var [key,value] of map)&#123;console.log(key,value);//这时map的默认值是enteries,也就是map.enteries( ),&#125; 单独获取a b c d 12345678910var map =new Map();map.set('a','apple');map.set('b','banana');map.set('c','orange');map.set('d','pear');for(var key of map.keys())&#123;console.log(key);&#125;//循环val 同理","tags":[{"name":"ES6语法","slug":"ES6语法","permalink":"https://liuyu595.github.io/tags/ES6语法/"}]},{"title":"”ES6入门笔记（一）“","date":"2017-03-12T03:03:33.000Z","path":"2017/03/12/ES6入门笔记（一）“/","text":"摘要： 之前我们接触到的js主要是由ECMA DOM BOM组成的。ES6就是之前的一个版本的迭代。 ECMA是标准，JS是实现者；换句话说还有可能有其他的版本来实现ECMA. 目前浏览器：主要分为两种一个是高级低级浏览器：主要支持ES3.1;高级浏览器正在从ES5到ES6过度。 正文: 直接在node里面使用： 1.直接用，需要在相应的js文件中头部添加‘ues strict’; 2.nede –harmony_destructuring xxx.js; 定义变量——let(目前位置已经被浏览器支持，不用引入js)； 代码块：{}包起来的代码叫代码块； 例如：{ let a=12; alert(a); //是可以在浏览器中拿到的 } alert(a)//这里的这个a 在浏览器中是不能被拿到的。 所以用{}包起来后就形成了一个作用域，这个作用域之能在相应的块中实现； let 声明的变量与 var声明的变量不同的是，var只有在函数体中才有作用域，而let与此不同； 封闭空间的问题： 之前用var声明一个变量的时候： for(var i=; i&lt;aBtn.length; i++){ (function(i){ aBtn[i].onclick=function(){ alert(i); } })(i); }; // 这样写的原因是var 没有一个封闭空间所以要用一个自运行函数在包裹它； 那么现在的let 是什么样子呢？for(let i=0; i&lt;aBtn.length;i++){ aBtn[i].onclick=function(){ alert(i);} 如果出现了一个大组件怎么办呢？怎么办呢？怎么办呢～！逗比呢？不是有const来定义敞亮么？常量一旦赋值就没有办法再修改了呀～！ ———————————————————————————————— 下面说下字符串链接：（个人感觉没有什么区别，估计是之前用习惯了吧） 反单引号 字符串模版 ： var str=`` 这两个单引号就是 数字1键前面的那个东西～ ·阿斯顿$(变量名)风格化` ———————————————————————————————— 解构赋值：var [a,b,c]=[12,3,5] 那么json的解构赋值就是：var {a,b,c}={a:2,b:3,c:3}; 注意：解构赋值时 要对应名字～！！！！切记～切记～！ 模式匹配：——————左边和右边的样式一样 var [a,[b,c],d]=[12,[1,2],5]; 此外补充一点解构赋值是可以给默认值的： 语法：var {time=12,id=0}={} 然而之前的方法是这样的：var json={}; var a=json.a||12 今天就到此为止吧～ 还是那句话，每天多学一点，就能少打一行代码～！","tags":[{"name":"ES6语法","slug":"ES6语法","permalink":"https://liuyu595.github.io/tags/ES6语法/"}]},{"title":"放眼看世界","date":"2017-03-09T03:42:59.000Z","path":"2017/03/09/see-word/","text":"摘要： 测试第一个博客文章正文：走自己的路，让别人羡慕","tags":[{"name":"放眼看世界 世界都亮了","slug":"放眼看世界-世界都亮了","permalink":"https://liuyu595.github.io/tags/放眼看世界-世界都亮了/"}]},{"title":"Hello World","date":"2017-03-09T02:49:02.000Z","path":"2017/03/09/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]