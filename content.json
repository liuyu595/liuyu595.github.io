[{"title":"ES5和ES6中对于继承的实现方法","date":"2017-06-04T14:12:59.000Z","path":"2017/06/04/ES5和ES6中对于继承的实现方法/","text":"摘要：温故知新，结合ES5和ES6对继承实现方法总结。 正文:ES6已经出来了好长时间了，今天没事把ES5的继承看了一遍，做一下复习巩固。顺便看下ES6和ES5的区别。在ES5继承的实现非常有趣的，由于没有传统面向对象类的概念，JavaScript利用原型链的特性来实现继承，这其中有很多的属性指向和需要注意的地方。至于原型、原型链的特点和实现在上一篇文章中写过了，就是通过将子类构造函数的原型作为父类构造函数的实例（sub.prototype=new super），这样就连通了子类-子类原型-父类，原型链的特点就是逐层查找，从子类开始一直往上直到所有对象的原型Object.prototype，找到属性方法之后就会停止查找，所以下层的属性方法会覆盖上层。一个基本的基于原型链的继承过程大概是如下：1234567891011121314151617181920//先来个父类，带些属性function Super()&#123;this.flag = true;&#125;//为了提高复用性，方法绑定在父类原型属性上Super.prototype.getFlag = function()&#123;return this.flag;&#125;//来个子类function Sub()&#123;this.subFlag = false;&#125;//实现继承Sub.prototype = new Super;//给子类添加子类特有的方法，注意顺序要在继承之后Sub.prototype.getSubFlag = function()&#123;return this.subFlag;&#125;//构造实例var es5 = new Sub; 看完ES5的实现，再来看看ES6的继承实现方法，其内部其实也是ES5组合继承的方式，通过call借用构造函数，在A类构造函数中调用相关属性，再用原型链的连接实现方法的继承。123456class B extends A &#123;constructor() &#123; //constructor在ES5中是隐藏起来的一个指针，指向父级的，这里直接单拉出来做一个方法使用。return A.call(this); //继承属性&#125;&#125;A.prototype = new B; //继承方法 ES6封装了class，extends关键字来实现继承，内部的实现原理其实依然是基于上面所讲的原型链，不过进过一层封装后，Javascript的继承得以更加简洁优雅地实现123456789class ColorPoint extends Point &#123;constructor(x, y, color) &#123;super(x, y); // 等同于parent.constructor(x, y)this.color = color;&#125;toString() &#123;return this.color + ' ' + super.toString(); // 等同于parent.toString()&#125;&#125; 转至：http://www.jianshu.com/p/342966fdf816","tags":[{"name":"js","slug":"js","permalink":"https://liuyu595.github.io/tags/js/"}]},{"title":"理解原型对象、prototype和 __proto__","date":"2017-06-04T14:11:27.000Z","path":"2017/06/04/理解原型对象、prototype和-proto/","text":"摘要：探究和理解原型对象、prototype和 proto 正文:当我们创建每一个函数的时候，都会有一个原型（prototype）属性,这个原型属性是一个指针，指向一个对象，而这个对象中包含可以由特定类型的所有实例共享方法和属性。在默认的情况下，所有对象都会获得一个constructor(构造函数)属性，这个属性包含一个指向prototype属性所在的函数指针。例如：12sayName ()==&gt;sayName.prototype==&gt;带出来一个constructor ==&gt;指针指向==&gt;sayName//然后可以重新给予新的属性。 参考:js中proto和prototype的区别和关系原型链概念那么proto是什么？我们在这里简单地说下。每个对象都会在其内部初始化一个属性，就是proto，当我们访问一个对象的属性 时，如果这个对象内部不存在这个属性，那么他就会去proto里找这个属性，这个proto又会有自己的proto，于是就这样 一直找下去，也就是我们平时所说的原型链的概念。按照标准，proto是不对外公开的，也就是说是个私有属性，但是Firefox的引擎将他暴露了出来成为了一个共有的属性，我们可以对外访问和设置。123456789101112131415161718var Person = function () &#123; &#125;;Person.prototype.Say = function () &#123;alert(&quot;Person say&quot;);&#125;Person.prototype.Salary = 50000;var Programmer = function () &#123; &#125;;Programmer.prototype = new Person();Programmer.prototype.WriteCode = function () &#123;alert(&quot;programmer writes code&quot;);&#125;;Programmer.prototype.Salary = 500;var p = new Programmer();p.Say();p.WriteCode();alert(p.Salary); 我们来做这样的推导： var p=new Programmer()可以得出p.proto=Programmer.prototype; 而在上面我们指定了Programmer.prototype=new Person();我们来这样拆分，var p1=new Person();Programmer.prototype=p1;那么: p1.proto=Person.prototype; Programmer.prototype.proto=Person.prototype; 由根据上面得到p.proto=Programmer.prototype。可以得到p.proto.proto=Person.prototype。 好，算清楚了之后我们来看上面的结果,p.Say()。由于p没有Say这个属性，于是去p.proto，也就是 Programmer.prototype，也就是p1中去找，由于p1中也没有Say，那就去p.proto.proto，也就是 Person.prototype中去找，于是就找到了alert(“Person say”)的方法。 其余的也都是同样的道理。 这也就是原型链的实现原理。 最后，其实prototype只是一个假象，他在实现原型链中只是起到了一个辅助作用，换句话说，他只是在new的时候有着一定的价值，而原型链的本质，其实在于proto！","tags":[{"name":"js","slug":"js","permalink":"https://liuyu595.github.io/tags/js/"}]},{"title":"vue中 .babelrc文件的一些简单的配置","date":"2017-06-04T14:10:04.000Z","path":"2017/06/04/vue中-babelrc文件的一些简单的配置/","text":"首先现在根目录先生存.babelrc文件，这个文件是用来设置转码的规则和插件的。 如果想使用es6语法，必须安装插件： npm install babel-preset-es2015 什么是.babelrc文件呢？ 熟悉Linux的同学一定知道，rc结尾的文件通常代表运行时自动加载的文件，配置等等，类似bashrc,zshrc而且在babel6中，这个文件必不可少。 里面可以对babel命令进行配置，以后再使用babel的cli的时候，可以少一些配置。还有一个env字段，可以对BABEL_ENV或者NODE_ENV指定的不同的环境变量，进行不同的编译操作“presets”这个是babel6新加的，就是代表需要启动什么样的预设转码，在babel中，预设了6中，分别是es2015 ,stage-0 , stage-1 ,stage-2 , stage-3 ,React require hookrequire hook 的作用就是替换原来的require，以便在自动加载对代码进行编译运行其实这个做的便是重写require.extensions 中对应的扩展名的加载程序，并且默认会判断这个文件是否是 node_modulesz中的模块。，如果是的话，那么将不会进行转换。否则的话进行转换基本的格式就是12345&#123;&quot;presets&quot;: [&quot;es2015&quot;, &quot;stage-2&quot;],&quot;plugins&quot;: [&quot;transform-runtime&quot;],&quot;comments&quot;: false&#125;","tags":[{"name":"vue","slug":"vue","permalink":"https://liuyu595.github.io/tags/vue/"}]},{"title":"vue中package.js两种配置依赖说明","date":"2017-06-04T14:08:38.000Z","path":"2017/06/04/vue中package-js两种配置依赖说明/","text":"一个node package有两种依赖，一种是dependencies一种是devDependencies，其中前者依赖的项该是正常运行该包时所需要的依赖项，而后者则是开发的时候需要的依赖项，像一些进行单元测试之类的包。 如果你将包下载下来在包的根目录里运行 npm install 默认会安装两种依赖，如果你只是单纯的使用这个包而不需要进行一些改动测试之类的，可以使用 npm install –production 只安装dependencies而不安装devDependencies。 如果你是通过以下命令进行安装 npm install packagename 那么只会安装dependencies，如果想要安装devDependencies，需要输入 npm install packagename –dev。","tags":[{"name":"vue","slug":"vue","permalink":"https://liuyu595.github.io/tags/vue/"}]},{"title":"webpack.json配置参数","date":"2017-06-04T14:05:15.000Z","path":"2017/06/04/webpack-json配置参数/","text":"摘要：项目配置及js脚本功能 正文:配置参数及功能说明：说明：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&#123;\"name\": \"node-web\",\"version\": \"0.0.0\",\"private\": true,\"scripts\": &#123;//运行 npm run dev后直接依次运行webpack中下面脚本。\"start\": \"node ./bin/www\",\"build\": \"webpack --progress --profile --colors --config webpack.prod.config.js\",\"start:dev\": \"webpack-dev-server --progress --config webpack.dev.config.js\",\"watch\": \"webpack --progress --colors --watch --config webpack.watch.config.js\"&#125;,\"dependencies\": &#123;\"body-parser\": \"~1.16.0\", //express的中间件bodyParser\"busboy\": \"^0.2.14\", //node上传模块busboy\"captchapng\": \"0.0.1\", //captchapng模块可以解决Nodejs图片验证码\"cookie-parser\": \"~1.4.3\", //cookieParser中间件用于获取web浏览器发送的cookie中的内容.\"debug\": \"~2.6.0\", //用来调手机端的\"echarts\": \"^3.4.0\",\"ejs\": \"~2.5.5\", //node模版\"element-ui\": \"^1.2.8\",\"es3ify-loader\": \"^0.2.0\", //基于webpack打包后兼容Ie8\"express\": \"~4.14.1\",\"express-session\": \"^1.15.2\", //可以判断客户的登录状态，做出提示，相当于登录拦截\"file-loader\": \"^0.10.1\", //ile-loader主要用来处理图片\"jquery.cookie\": \"^1.4.1\", //浏览器的cookie读取\"lodash\": \"^4.17.4\", //lodash是为了提供更多“一致的跨浏览器行为\"log4js\": \"^1.1.1\", //用于日志的模块管理及封装\"matchdep\": \"^1.0.1\",\"moment\": \"^2.18.1\", //是一个 JavaScript 日期处理类库,用于解析、检验、操作、以及显示日期\"morgan\": \"~1.7.0\", //Mogran是一个node.js关于http请求的日志中间件。\"node-xlsx\": \"^0.7.4\", //nodejs读写excel内容\"optimize-css-assets-webpack-plugin\": \"^1.3.0\",\"redis\": \"^2.7.1\", //解决大量数据存储\"serve-favicon\": \"~2.3.2\",\"ueditor\": \"^1.2.2\", //富文本编辑器\"vue\": \"^2.2.4\",\"vue-quill-editor\": \"^2.2.1\",\"vue-resource\": \"^1.2.1\",\"vue-router\": \"^2.4.0\"&#125;,\"devDependencies\": &#123;\"autoprefixer\": \"^6.7.7\",\"autoprefixer-loader\": \"^3.2.0\",\"babel-core\": \"^6.24.0\",\"babel-loader\": \"^6.4.1\",\"babel-preset-es2015\": \"^6.24.1\",\"babili-webpack-plugin\": \"0.0.11\",\"css-loader\": \"^0.27.3\",\"eventsource-polyfill\": \"^0.9.6\",\"extract-text-webpack-plugin\": \"^2.1.0\",\"file-loader\": \"^0.10.1\",\"grunt-webpack-server\": \"^0.1.0\",\"html-webpack-plugin\": \"^2.28.0\",\"jquery\": \"1.12.4\",\"less\": \"^2.7.2\",\"less-loader\": \"^3.0.0\",\"postcss-loader\": \"^1.3.3\",\"precss\": \"^1.4.0\",\"style-loader\": \"^0.13.2\",\"uglify-js\": \"^2.8.21\",\"url-loader\": \"^0.5.8\",\"vue-loader\": \"^11.1.4\",\"vue-style-loader\": \"^2.0.0\",\"vue-template-compiler\": \"^2.2.1\",\"webpack\": \"^2.2.1\",\"webpack-dev-middleware\": \"^1.10.0\", //热重载\"webpack-dev-server\": \"^2.4.1\",\"webpack-hot-middleware\": \"^2.18.0\",\"webpack-md5-hash\": \"0.0.5\",\"webpack-merge\": \"^2.6.1\"&#125;&#125;","tags":[{"name":"webpack","slug":"webpack","permalink":"https://liuyu595.github.io/tags/webpack/"}]},{"title":"ES6 const之误区","date":"2017-06-04T14:03:39.000Z","path":"2017/06/04/ES6-const之误区/","text":"ES6中的 const 很多人都被认为是常量，常量是不能被更改的。今天室友说const是可以被更改的。那么我就带着好奇和疑问来揭开const 的真正面纱。 正文:之前看了好多视频（〇课、〇〇课堂，视频中都说是常量，）来学习ES6语法，前端么～要与时俱进的啦。const 常量索引，不是值。在ES6中另外一个定义变量的关键字是 const , 但是它经常被误会为一个“常量”。在ES6中， const 代表一个值的 常量索引 （事实上绝大多数语言都提供这样的功能）。换句话说，变量名字在内存中的指针不能够改变，但是指向这个变量的值 可能 改变。 这里有一个简单的例子。在下面的例子中我们可以创建一个拥有常量索引的数组变量。我们在之后添加值到这个数组中并不改变这个索引，一切都可以运行起来：const names = [ ] ; names . push ( “Jordan” ) ; console . log ( names ) ; 但是，如果我们尝试修改变量索引到一个新的数组——即使是和现在内容一样的数组——我们将获得一个SyntaxError (“Assignment to constant variable”)： const names = [ ] ; names = [ ] ; // Error! 当然，如果你拥有一个指向string或者number的 const ，当然这里就不会有任何可以修改的值。所有String和Number的方法返回 新的 值(对象)。 最后一个关于使用 const 的注意事项是参考 let 的新作用域规则！那意味着我们应该在我们的代码中使用 let 和 const 完全代替 var 。事实上，依然有很多人支持作为没有涉及到的遗留代码只“允许”使用 var 的想法当一个程序员在一个文件中更新一些代码，他们应该 (并且可能)将所有 var 语句更新为适当的有适当作用域的 let 或者 const 。","tags":[{"name":"ES6","slug":"ES6","permalink":"https://liuyu595.github.io/tags/ES6/"}]},{"title":"使用js实现前端缓存","date":"2017-06-04T14:00:19.000Z","path":"2017/06/04/使用js实现前端缓存/","text":"摘要：在前端浏览器中，有些数据（比如数据字典中的数据），可以在第一次请求的时候全部拿过来保存在js对象中，以后需要的时候就不用每次都去请求服务器了。对于那些大量使用数据字典来填充下拉框的页面，这种方法可以极大地减少对服务器的访问。这种方法特别适用于使用iframe的框架。 正文: 在前端浏览器中，有些数据（比如数据字典中的数据），可以在第一次请求的时候全部拿过来保存在js对象中，以后需要的时候就不用每次都去请求服务器了。对于那些大量使用数据字典来填充下拉框的页面，这种方法可以极大地减少对服务器的访问。这种方法特别适用于使用iframe的框架。因为很多能可以模拟MAP( )对象，所以简单写一下小例子以便于以后参考回顾： 创建一个cache.js文件： 1234567891011121314/*** 定义需要在用户登录的时候获取到本地的数据字典类别*/var clsCodes = &#123;\"clsCodes\" :[\"BOOL\",\"STATUS\",\"USER_TYPE\",\"REPORT_STATUS\"]&#125;;/*** 获取数据字典到本地*/var dicts; //全局变量 前端页面，定义一个函数来调用后台接口获取数据，然后保存到本地缓存对象（dicts）中。 12345678910function getDicts() &#123; $.post(getContextPath() + \"/api/sys/getDictList\", clsCodes, function(resultBean, status, xhRequest) &#123; if (resultBean.data != undefined) &#123; dicts = resultBean.data; &#125; &#125;, 'json');&#125; 在主页面加载的时候调用这个方法一次性获取数据并缓存起来。这样，以后需要同样的数据，就直接从本地对象dicts中获取了 后端Controller： 定义一个接口，根据前端的请求，查询数据库（或查询服务器缓存，如下面例子中）获取数据返回给前端：1234567891011121314151617181920212223242526272829/*** 根据多个分类编号获取多个字典集合* @param clsCodes* @return &#123;&#123;\"clsCode\" : &#123;\"code1\":\"name1,\"code2\":\"name2\"...&#125;&#125;, ...&#125;*/@SuppressWarnings(&#123; \"unchecked\", \"rawtypes\" &#125;)@ResponseBody@RequestMapping(\"getDictList\")//ResultBean 返回值 //getDictList 数据接口public ResultBean getDictList(@RequestParam(value = \"clsCodes[]\", required = true) String[] clsCodes) &#123;ResultBean rb = new ResultBean();Map&lt;String, Map&lt;String, String&gt;&gt; dictCache = (Map&lt;String, Map&lt;String, String&gt;&gt;) CacheManager.getInstance().get(CacheConstants.DICT);Map dictMap = new LinkedHashMap&lt;&gt;(); //使用LinkedHashMap保证顺序if(dictCache != null)&#123; for(String clsCode: clsCodes)&#123; dictMap.put(clsCode, dictCache.get(clsCode)); &#125;&#125;else&#123; rb.setMessage(\"缓存中拿不到字典信息！\"); rb.setSuccess(false);&#125; rb.setData(dictMap); return rb;&#125;","tags":[{"name":"js","slug":"js","permalink":"https://liuyu595.github.io/tags/js/"}]},{"title":"H5播放器源码解读video.js(一)","date":"2017-05-24T14:02:02.000Z","path":"2017/05/24/H5播放器源码解读（video-js）/","text":"摘要：最近公司部门发展有点问题，于是被流放到了公司的研发中心，虽然继续做视频会议项目，但是要求比较之前要高的太多了。都是大项目，而且都是软件往硬件集成发展。说下为什么看video.js吧，起初呢我也知道有这个东西，毕竟在之前的部门接触的有点浅吧。来到研发中心的第二天有个妹子问我video.js,当时也没有仔细看。只是说了下大概的思路。也不知道解决了没有(｡ì _ í｡)。正文：今天就来好好研究下video.js这个插件，下面言归正传。 组织结构由于源码量较大，很多同学不知道从何入手，我们先来说下它的组织结构。 ├── control-bar├── menu├── popup├── slider├── tech├── tracks├── utils├── big-play-button.js├── button.js├── clickable-component.js├── close-button.js├── component.js├── error-display.js├── event-target.js├── extend.js├── fullscreen-api.js├── loading-spinner.js├── media-error.js├── modal-dialog.js├── player.js├── plugins.js├── poster-image.js├── setup.js└── video.js 其中control-bar，menu，popup，slider，tech，tracks，utils是目录，其他是文件。video.js是个非常优秀的面向对象的典型，所有的UI都是通过JavaScript对象组织实现的。video.js是个入口文件，看源码可以从这个文件开始。 setup.js处理播放器的配置安装即data-setup属性。 poster-image.js处理播放器贴片。 plugins.js实现了插件机制。 player.js构造了播放器类也是video.js的核心。 modal-dialog.js处理弹层相关。 media-error.js定义了各种错误描述，如果想理解video.js对各语言的支持，这个文件是必看的，它是桥梁。 loading-spinner.js实现了播放器加载的标志，如果不喜欢默认加载图标在这里修改吧。 fullscreen-api.js实现各个浏览器的全屏方案。 extend.js是对node 继承 and babel’s 继承的整合。 event-target.js 是event类和原生事件的兼容处理。 error-display.js 主要处理展示错误的样式设置。 component.js 是video.js框架中最重要的类，是所有类的基类，也是实现组件化的基石。 close-button.js 是对关闭按钮的封装，功能比较单一。 clickable-component.js 如果想实现一个支持点击事件和键盘事件具备交互功能的组件可以继承该类，它帮你做了细致的处理。 button.js 如果想实现一个按钮了解下这个类是必要的。 big-play-button.js 这个按钮是视频还未播放时显示的按钮，官方将此按钮放置在播放器左上角。 utils目录顾名思义是一些常用的功能性类和函数。 tracks目录处理的是音轨、字幕之类的功能。 tech目录也是非常核心的类，包括对video封装、flash的支持。 slider目录主要是UI层面可拖动组件的实现，如进度条，音量条都是继承的此类。 popup目录包含了对弹层相关的类。 menu目录包含了对菜单UI的实现。 control-bar目录是非常核心的UI类的集合了，播放器下方的控制器都在此目录中。 通过对组织结构的描述，大家可以，想了解video.js的哪一部分内容可以快速入手。如果还想更深入的了解如何正确使用这些类，请继续阅读继承关系一节。 继承关系video.js是JavaScript面向对象实现很经典的案例，你一定会好奇在页面上一个DOM节点加上data-setup属性简单配置就能生成一个复杂的播放器，然而在代码中看不到对应的HTML”模板“。其实这都要归功于”继承“关系以及作者巧妙的构思。 在组织结构一节有提到，所有类的基类都是Component类，在基类中有个createEl方法这个就是JavaScript对象和DOM进行关联的方法。在具体的类中也可以重写该方法自定义DOM内容，然后父类和子类的DOM关系也因JavaScript对象的继承关系被组织起来。 运行机制video.js源码代码量比较大，我们要了解它的运行机制，首先确定它的主线是video.js文件的videojs方法，videojs方法调用player.js的Player类，Player继承component.js文件的Component类，最后播放器成功运行。 我们来看下videojs方法的代码、Player的构造函数、Component的构造函数，通过对代码的讲解基本整个运行机制就有了基本的了解，注意里面用到的所有方法和其他类对象参照组织结构一节细细阅读就可以掌握更多的运行细节。 videojs方法 12345678910111213141516171819202122232425262728293031function videojs(id, options, ready) &#123;let tag;// id可以是选择器也可以是DOM节点if (typeof id === 'string') &#123;if (id.indexOf('#') === 0) &#123;id = id.slice(1);&#125;//检查播放器是否已被实例化if (videojs.getPlayers()[id]) &#123;if (options) &#123;log.warn(`Player \"$&#123;id&#125;\"is already initialised.Options will not be applied.`);&#125;if (ready) &#123;videojs.getPlayers()[id].ready(ready);&#125;return videojs.getPlayers()[id];&#125;// 如果播放器没有实例化，返回DOM节点tag = Dom.getEl(id);&#125; else &#123;// 如果是DOM节点直接返回tag = id;&#125;if (!tag || !tag.nodeName) &#123;throw new TypeError('The element or ID supplied is not valid. (videojs)');&#125;// 返回播放器实例return tag.player || Player.players[tag.playerId] || new Player(tag, options, ready);&#125;[]() Player的构造函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107constructor(tag, options, ready) &#123;// 注意这个tag是video原生标签tag.id = tag.id || `vjs_video_$ &#123;Guid.newGUID()&#125;`;// 选项配置的合并options = assign(Player.getTagSettings(tag), options);// 这个选项要关掉否则会在父类自动执行加载子类集合options.initChildren = false;// 调用父类的createEl方法options.createEl = false;// 在移动端关掉手势动作监听options.reportTouchActivity = false;// 检查播放器的语言配置if (!options.language) &#123;if (typeof tag.closest === 'function') &#123;const closest = tag.closest('[lang]');if (closest) &#123;options.language = closest.getAttribute('lang');&#125;&#125; else &#123;let element = tag;while (element &amp;&amp; element.nodeType === 1) &#123;if (Dom.getElAttributes(element).hasOwnProperty('lang')) &#123;options.language = element.getAttribute('lang');break;&#125;element = element.parentNode;&#125;&#125;&#125;// 初始化父类super(null, options, ready);// 检查当前对象必须包含techOrder参数if (!this.options_ || !this.options_.techOrder || !this.options_.techOrder.length) &#123;throw new Error('No techOrder specified. Did you overwrite ' +'videojs.options instead of just changing the ' +'properties you want to override?');&#125;// 存储当前已被实例化的播放器this.tag = tag;// 存储video标签的各个属性this.tagAttributes = tag &amp;&amp; Dom.getElAttributes(tag);// 将默认的英文切换到指定的语言this.language(this.options_.language);if (options.languages) &#123;const languagesToLower = &#123;&#125;;Object.getOwnPropertyNames(options.languages).forEach(function (name) &#123;languagesToLower[name.toLowerCase()] = options.languages[name];&#125;);this.languages_ = languagesToLower;&#125; else &#123;this.languages_ = Player.prototype.options_.languages;&#125;// 缓存各个播放器的各个属性.this.cache_ = &#123;&#125;;// 设置播放器的贴片this.poster_ = options.poster || '';// 设置播放器的控制this.controls_ = !! options.controls;// 默认是关掉控制tag.controls = false;this.scrubbing_ = false;this.el_ = this.createEl();const playerOptionsCopy = mergeOptions(this.options_);// 自动加载播放器插件if (options.plugins) &#123;const plugins = options.plugins;Object.getOwnPropertyNames(plugins).forEach(function (name) &#123;if (typeof this[name] === 'function') &#123;this[name](plugins[name]);&#125; else &#123;log.error('Unable to find plugin:', name);&#125;&#125;, this);&#125;this.options_.playerOptions = playerOptionsCopy;this.initChildren();// 判断是不是音频this.isAudio(tag.nodeName.toLowerCase() === 'audio');if (this.controls()) &#123;this.addClass('vjs-controls-enabled');&#125; else &#123;this.addClass('vjs-controls-disabled');&#125;this.el_.setAttribute('role', 'region');if (this.isAudio()) &#123;this.el_.setAttribute('aria-label', 'audio player');&#125; else &#123;this.el_.setAttribute('aria-label', 'video player');&#125;if (this.isAudio()) &#123;this.addClass('vjs-audio');&#125;if (this.flexNotSupported_()) &#123;this.addClass('vjs-no-flex');&#125;if (!browser.IS_IOS) &#123;this.addClass('vjs-workinghover');&#125;Player.players[this.id_] = this;this.userActive(true);this.reportUserActivity();this.listenForUserActivity_();this.on('fullscreenchange', this.handleFullscreenChange_);this.on('stageclick', this.handleStageClick_);&#125; Component的构造函数123456789101112131415161718192021222324252627282930313233343536373839constructor(player, options, ready) &#123;// 之前说过所有的类都是继承Component，不是所有的类需要传playerif (!player &amp;&amp; this.play) &#123;// 这里判断调用的对象是不是Player本身，是本身只需要返回自己this.player_ = player = this; // eslint-disable-line&#125; else &#123;this.player_ = player;&#125;this.options_ = mergeOptions(&#123;&#125;, this.options_);options = this.options_ = mergeOptions(this.options_, options);this.id_ = options.id || (options.el &amp;&amp; options.el.id);if (!this.id_) &#123;const id = player &amp;&amp; player.id &amp;&amp; player.id() || 'no_player';this.id_ = `$ &#123;id&#125;_component_$ &#123;Guid.newGUID()&#125;`;&#125;this.name_ = options.name || null;if (options.el) &#123;this.el_ = options.el;&#125; else if (options.createEl !== false) &#123;this.el_ = this.createEl();&#125;this.children_ = [];this.childIndex_ = &#123;&#125;;this.childNameIndex_ = &#123;&#125;;// 知道Player的构造函数为啥要设置initChildren为false了吧if (options.initChildren !== false) &#123;// 这个initChildren方法是将一个类的子类都实例化，一个类都对应着自己的el（DOM实例），通过这个方法父类和子类的DOM继承关系也就实现了this.initChildren();&#125;this.ready(ready);if (options.reportTouchActivity !== false) &#123;this.enableTouchActivity();&#125;&#125; 这里通过主线把基本的流程演示一下，轮廓出来了，更多细节还请继续阅读。 插件机制一个完善和强大的框架都会继承插件运行功能，给更多的开发者参与开发的机会进而实现框架功能的补充和延伸。我们来看下video.js的插件是如何运作的。 插件的定义1234567import Player from './player.js';// 将插件种植到Player的原型链const plugin = function (name, init) &#123;Player.prototype[name] = init;&#125;;// 暴露plugin接口videojs.plugin = plugin; 不难看出，原理就是将插件（函数）挂载到Player对象的原型上，接下来看下是怎么执行的。 插件的运行12345678910if (options.plugins) &#123;const plugins = options.plugins;Object.getOwnPropertyNames(plugins).forEach(function (name) &#123;if (typeof this[name] === 'function') &#123;this[name](plugins[name]);&#125; else &#123;log.error('Unable to find plugin:', name);&#125;&#125;, this);&#125; 在Player的构造函数里判断是否有插件这个配置，如果有则遍历执行。 UI”继承”的原理在继承关系一节中有提到video.js的所有DOM生成都不是采用的传统模板的方式，都是通过JavaScript对象的继承关系来实现的。 在Component基类中有个createEl方法，在这里可以使用DOM类生成DOM实例。每个UI类都会有一个el属性，会在实例化的时候自动生成，源代码在Component的构造函数中：12345if (options.el) &#123; this.el_ = options.el;&#125; else if (options.createEl !== false) &#123;this.el_ = this.createEl();&#125; 每个UI类有一个children属性，用于添加子类，子类有可能扔具有children属性，以此类推，播放器的DOM结构就是通过这样的JavaScript对象结构实现的。 在Player的构造函数里有一句代码this.initChildren();启动了UI的实例化。这个方法是在Component基类中定义的，我们来看下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566initChildren() &#123; // 获取配置的children选项const children = this.options_.children;if (children) &#123;const parentOptions = this.options_;const handleAdd = (child) =&gt; &#123;const name = child.name;let opts = child.opts;if (parentOptions[name] !== undefined) &#123;opts = parentOptions[name];&#125;if (opts === false) &#123;return;&#125;if (opts === true) &#123;opts = &#123;&#125;;&#125;opts.playerOptions = this.options_.playerOptions;const newChild = this.addChild(name, opts);if (newChild) &#123;this[name] = newChild;&#125;&#125;;let workingChildren;const Tech = Component.getComponent(&apos;Tech&apos;);if (Array.isArray(children)) &#123;workingChildren = children;&#125; else &#123;workingChildren = Object.keys(children);&#125;workingChildren.concat(Object.keys(this.options_).filter(function(child) &#123;return !workingChildren.some(function(wchild) &#123;if (typeof wchild === &apos;string&apos;) &#123;return child === wchild;&#125;return child === wchild.name;&#125;);&#125;)).map((child) =&gt; &#123;let name;let opts;if (typeof child === &apos;string&apos;) &#123;name = child;opts = children[name] || this.options_[name] || &#123;&#125;;&#125; else &#123;name = child.name;opts = child;&#125;return &#123;name, opts&#125;;&#125;).filter((child) =&gt; &#123;const c = Component.getComponent(child.opts.componentClass ||toTitleCase(child.name));return c &amp;&amp; !Tech.isTech(c);&#125;).forEach(handleAdd);&#125;&#125; 通过这段代码不难看出大概的意思是通过initChildren获取children属性，然后遍历通过addChild将子类实例化，实例化的过程会自动重复上述过程从而达到了”继承“的效果。不得不为作者的构思点赞。如果你要问并没看到DOM是怎么关联起来的，请继续看addChild方法的源码：options = &#123;&#125;, index = this.children_.length) &#123; 12345678910111213141516171819202122232425262728293031323334353637383940let component;let componentName;if (typeof child === &apos;string&apos;) &#123;componentName = child;if (!options) &#123;options = &#123;&#125;;&#125;if (options === true) &#123;log.warn(&apos;Initializing a child component with `true` is deprecated. Children should be defined in an array when possible, but if necessary use an object instead of `true`.&apos;);options = &#123;&#125;;&#125;const componentClassName = options.componentClass || toTitleCase(componentName);options.name = componentName;const ComponentClass = Component.getComponent(componentClassName);if (!ComponentClass) &#123;throw new Error(`Component $&#123;componentClassName&#125; does not exist`);&#125;if (typeof ComponentClass !== &apos;function&apos;) &#123;return null;&#125;component = new ComponentClass(this.player_ || this, options);&#125; else &#123;component = child;&#125;this.children_.splice(index, 0, component);if (typeof component.id === &apos;function&apos;) &#123;this.childIndex_[component.id()] = component;&#125;componentName = componentName || (component.name &amp;&amp; component.name());if (componentName) &#123;this.childNameIndex_[componentName] = component;&#125;if (typeof component.el === &apos;function&apos; &amp;&amp; component.el()) &#123;const childNodes = this.contentEl().children;const refNode = childNodes[index] || null;this.contentEl().insertBefore(component.el(), refNode);&#125;return component;&#125; 这段代码的大意就是提取子类的名称，然后获取类并实例化，最后通过最关键的一句话this.contentEl().insertBefore(component.el(), refNode);完成了父类和子类的DOM关联。相信inserBefore大家并不陌生吧，原生的DOM操作方法。","tags":[{"name":"video.js","slug":"video-js","permalink":"https://liuyu595.github.io/tags/video-js/"}]},{"title":"Cornerstone 3.0.1Mac安装和使用","date":"2017-05-23T15:14:10.000Z","path":"2017/05/23/Cornerstone-3-0-1Mac安装和使用/","text":"摘要：由于项目的需要，公司代码版本控制用的是SVN。在网上找了好久也没有找到一个好用的、免费的。在这里感谢下史蒂芬周的博客提供了这个SVN代码版本管理器。此笔记仅作为以后的参考和记录，以便不时之需。 正文： 软件下载Cornerstone 3.0.1Mac破解版网盘下载注： 系统版本要求：OS X 10.11 或更高。 破解方法请按照下面一步一步的来 安装APP。 想必你在安装的过程中会发现文件损坏，请往下看。 打开系统偏好设置–&gt;通用–&gt;任何来源。(｡ì _ í｡) oh~shit~!! 什么鬼，任何来源在哪里？难道我的MAC是假的？不比着急，接着往下看～(^o^)～ 打开终端，听话～！这次不骗你了。 //记着是两个小减号这样会看到‘任何来源’这个选项。$ sudo spctl –master-disable//关闭“任何来源”选项$ sudo spctl –master-enable//移除“任何来源”选项$ sudo spctl –master-remove 使用方法参考方法","tags":[{"name":"SVN","slug":"SVN","permalink":"https://liuyu595.github.io/tags/SVN/"}]},{"title":"正则表达式（二）","date":"2017-05-21T14:43:39.000Z","path":"2017/05/21/正则表达式（二）/","text":"摘要：第二部分；总最全正则表达式总结：验证QQ号、手机号、Email、中文、邮编、身份证等。正文： 支持正则表达式的 String 对象的方法1.search 检索与正则表达式相匹配的值1var str = \"Visit W3School!\"console.log(str.search(/W3School/))// OUTPUT:6 2.match 找到一个或多个正则表达式的匹配。1var str=\"1 plus 2 equal 3\"console.log(str.match(/\\d+/g))// OUTPUT:1,2,3 ###3.replace 替换与正则表达式匹配的子串。1234567891011121314151617var str = \"Visit Microsoft!\"console.log(str.replace(/Microsoft/, \"W3School\"));// OUTPUT:Visit W3School!// 找重复项最多的字符个数var str = 'g21ss4aeba_ersb43sgnnsssstht6sss60snnsj8resw0_ss';// split : 将字符串转化为数组// sort : 对数组排序，ASCII// join : 将数组转化为字符串var str_new = str.split('').sort().join('');document.write(str + '&lt;br&gt;');document.write(str.split('') + '&lt;br&gt;');document.write(str.split('').sort() + '&lt;br&gt;');document.write(str.split('').sort().join('') + '&lt;br&gt;');// 匹配字符，且重复这个字符，重复次数至少一次。var regexp = /(\\w)\\1+/g;var index = 0;var value = '';str_new.replace(regexp, function($0, $1) &#123;// document.write($0);// document.write($1); if (index &lt; $0.length) &#123;index = $0.length;value = $1;&#125;&#125;);document.write('重复项最多的字符是：' + value + '，个数是：' + index);// OUTPUT:// 0012344668__aabbeeegghjnnnnrrssssssssssssssssttw// 重复项最多的字符是：s，个数是：16 4.split 把字符串分割为字符串数组。1var str = \"How are you doing today?\"document.write(str.split(/\\s+/));// OUTPUT:How,are,you,doing,today? 经验： 验证格式（邮箱格式、IP格式）是否正确，用test ( ); 抓取星期（如所所有手机号），用exec( )、match( ) 替换敏感词汇，用replace ( )常见的 正则表达式 校验12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 常见的 正则表达式 校验// QQ号、手机号、Email、是否是数字、去掉前后空格、是否存在中文、邮编、身份证var myRegExp = &#123; // 检查字符串是否为合法QQ号码// 1 首位不能是0 ^[1-9]// 2 必须是 [5, 11] 位的数字 \\d&#123;4, 9&#125;isQQ: function(str) &#123;var reg = /^[1-9][0-9]&#123;4,9&#125;$/gim; if (reg.test(str)) &#123;console.log('QQ号码格式输入正确'); return true;&#125; else &#123;console.log('请输入正确格式的QQ号码'); return false;&#125;&#125;, // 检查字符串是否为合法手机号码 isPhone: function(str) &#123;var reg = /^(0|86|17951)?(13[0-9]|15[012356789]|18[0-9]|14[57]|17[678])[0-9]&#123;8&#125;$/; if (reg.test(str)) &#123;console.log('手机号码格式输入正确'); return true;&#125; else &#123;console.log('请输入正确格式的手机号码'); return false;&#125;&#125;, // 检查字符串是否为合法Email地址 isEmail: function(str) &#123;var reg = /^\\w+((-\\w+)|(\\.\\w+))*\\@[A-Za-z0-9]+((\\.|-)[A-Za-z0-9]+)*\\.[A-Za-z0-9]+$/; // var reg = /\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*/;if (reg.test(str)) &#123;console.log('Email格式输入正确'); return true;&#125; else &#123;console.log('请输入正确格式的Email'); return false;&#125;&#125;, // 检查字符串是否是数字 isNumber: function(str) &#123;var reg = /^\\d+$/; if (reg.test(str)) &#123;console.log(str + '是数字'); return true;&#125; else &#123;console.log(str + '不是数字'); return false;&#125;&#125;, // 去掉前后空格trim: function(str) &#123;var reg = /^\\s+|\\s+$/g; return str.replace(reg, '');&#125;, // 检查字符串是否存在中文isChinese: function(str) &#123;var reg = /[\\u4e00-\\u9fa5]/gm; if (reg.test(str)) &#123;console.log(str + ' 中存在中文'); return true;&#125; else &#123;console.log(str + ' 中不存在中文'); return false;&#125;&#125;, // 检查字符串是否为合法邮政编码// 起始数字不能为0，然后是5个数字 [1-9]\\d&#123;5&#125;isPostcode: function(str) &#123;var reg = /^[1-9]\\d&#123;5&#125;$/g; // var reg = /^[1-9]\\d&#123;5&#125;(?!\\d)$/;if (reg.test(str)) &#123;console.log(str + ' 是合法的邮编格式'); return true;&#125; else &#123;console.log(str + ' 是不合法的邮编格式'); return false;&#125;&#125;, // 检查字符串是否为合法身份证号码isIDcard: function(str) &#123;var reg = /^(^[1-9]\\d&#123;7&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;$)|(^[1-9]\\d&#123;5&#125;[1-9]\\d&#123;3&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])((\\d&#123;4&#125;)|\\d&#123;3&#125;[Xx])$)$/; if (reg.test(str)) &#123;console.log(str + ' 是合法的身份证号码'); return true;&#125; else &#123;console.log(str + ' 是不合法的身份证号码'); return false;&#125;&#125;, // 检查字符串是否为合法URLisURL: function(str) &#123;var reg = /^https?:\\/\\/(([a-zA-Z0-9_-])+(\\.)?)*(:\\d+)?(\\/((\\.)?(\\?)?=?&amp;?[a-zA-Z0-9_-](\\?)?)*)*$/i; if (reg.test(str)) &#123;console.log(str + ' 是合法的URL'); return true;&#125; else &#123;console.log(str + ' 是不合法的URL'); return false;&#125;&#125;, // 检查字符串是否为合法日期格式 yyyy-mm-ddisDate: function(str) &#123;var reg = /^[1-2][0-9][0-9][0-9]-[0-1]&#123;0,1&#125;[0-9]-[0-3]&#123;0,1&#125;[0-9]$/; if (reg.test(str)) &#123;console.log(str + ' 是合法的日期格式'); return true;&#125; else &#123;console.log(str + ' 是不合法的日期格式，yyyy-mm-dd'); return false;&#125;&#125;&#125;// 测试// console.log(myRegExp.isQQ('80583600'));// console.log(myRegExp.isPhone('17607160722'));// console.log(myRegExp.isEmail('80583600@qq.com'));// console.log(myRegExp.isNumber('100a'));// console.log(myRegExp.trim(' 100 '));// console.log(myRegExp.isChinese('baixiaoming'));// console.log(myRegExp.isChinese('小明'));// console.log(myRegExp.isPostcode('412345'));// console.log(myRegExp.isIDcard('42091119940927001X'));// console.log(myRegExp.isURL('https://www.baidu.com/'));// console.log(myRegExp.isDate('2017-4-4')); 校验数字的表达式1 数字：^[0-9]$2 n位的数字：^\\d{n}$3 至少n位的数字：^\\d{n,}$4 m-n位的数字：^\\d{m,n}$5 零和非零开头的数字：^(0|[1-9][0-9])$6 非零开头的最多带两位小数的数字：^([1-9][0-9])+(.[0-9]{1,2})?$7 带1-2位小数的正数或负数：^(-)?\\d+(.\\d{1,2})?$8 正数、负数、和小数：^(-|+)?\\d+(.\\d+)?$9 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$10 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$11 非零的正整数：^[1-9]\\d$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]$12 非零的负整数：^-[1-9][]0-9”$ 或 ^-[1-9]\\d$13 非负整数：^\\d+$ 或 ^[1-9]\\d|0$14 非正整数：^-[1-9]\\d|0$ 或 ^((-\\d+)|(0+))$15 非负浮点数：^\\d+(.\\d+)?$ 或 ^[1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0$16 非正浮点数：^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\\d.\\d|0.\\d[1-9]\\d))|0?.0+|0$17 正浮点数：^[1-9]\\d.\\d|0.\\d[1-9]\\d$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$18 负浮点数：^-([1-9]\\d.\\d|0.\\d[1-9]\\d)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$19 浮点数：^(-?\\d+)(.\\d+)?$ 或 ^-?([1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0)$ 校验字符的表达式1 汉字：^[\\u4e00-\\u9fa5]{0,}$2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$3 长度为3-20的所有字符：^.{3,20}$4 由26个英文字母组成的字符串：^[A-Za-z]+$5 由26个大写英文字母组成的字符串：^[A-Z]+$6 由26个小写英文字母组成的字符串：^[a-z]+$7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$8 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$9 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$10 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$11 可以输入含有^%&amp;’,;=?$\\”等字符：[^%&amp;’,;=?$\\x22]+12 禁止输入含有~的字符：[^~\\x22]+ 特殊需求表达式1 Email地址：^\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)$2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?3 InternetURL：[a-zA-z]+://[^\\s] 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$5 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$6 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7}7 身份证号(15位、18位数字)：^\\d{15}|\\d{18}$8 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.\\d)(?=.[a-z])(?=.[A-Z]).{8,10}$12 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2}13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$15 钱的输入格式：16 1.有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]$17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9])$18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9])$19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$20 5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})(.[0-9]{1,2})?$23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3}))(.[0-9]{1,2})?$24 备注：这就是最终结果了,别忘了”+”可以用”“替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$26 中文字符的正则表达式：[\\u4e00-\\u9fa5]27 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))28 空白行的正则表达式：\\n\\s\\r (可以用来删除空白行)29 HTML标记的正则表达式：&lt;(\\S?)[^&gt;]&gt;.?&lt;/\\1&gt;|&lt;.? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)30 首尾空白字符的正则表达式：^\\s|\\s$或(^\\s)|(\\s$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)31 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)32 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字)33 IP地址：\\d+.\\d+.\\d+.\\d+ (提取IP地址时有用)34 IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))","tags":[{"name":"RegExp 正则表达式","slug":"RegExp-正则表达式","permalink":"https://liuyu595.github.io/tags/RegExp-正则表达式/"}]},{"title":"正则表达式（一）","date":"2017-05-21T14:43:29.000Z","path":"2017/05/21/正则表达式（一）/","text":"摘要：第一部分；总最全正则表达式总结：验证QQ号、手机号、Email、中文、邮编、身份证等。正文： 什么是 RegExp RegExp 是正则表达式（Regular expression）的缩写，作用是对字符串执行模式匹配。 通常用于格式验证、正则替换、查找子串等 各种编程语言的正则表达式基本相同，不同的语言可能会有一些细小的差别 RegExp入门 完整的 RegExp 对象参考手册 RegExp 语法直接实例化var reg = new RegExp(pattern [, flags]);// 隐式创建(推荐)var reg = /pattern/flags; 参数 pattern 是一个字符串，指定了正则表达式的模式或其他正则表达式。 参数 [, flags] 是一个可选的字符串，包含属性 “g”（global ）、”i” （ignoreCase）和 “m”（multiline）。 ECMAScript 标准化之前，不支持 m 属性。如果 pattern 是正则表达式，而不是字符串，则必须省略该参数。| 修饰符 | 表述|| :——–:| :——–:|| i | 执行对大小写不敏感的匹配 || g | 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止） || m | 执行多行匹配 | 概念：子表达式在正则表达式中，使用括号括起来的内容是一个子表达式，子表达式匹配到的内容会被系统捕获至缓冲区，使用\\n（n：数字）来反向引用系统的第n号缓冲区的内容。 场景：后面的内容要求与前面的一致，可以使用子表达式 // 查找连续相同的四个数字var str = “1212ab45677778cd”;var reg = /(\\d)\\1\\1\\1/gi;console.log(str.match(reg));// OUTPUT:7777 概念：方括号（字符簇） [abc] 查找方括号之间的任何字符。 [^abc] 查找任何不在方括号之间的字符。 [0-9] 查找任何从 0 至 9 的数字。同 \\d [a-z] 查找任何从小写 a 到小写 z 的字符。 [A-Z] 查找任何从大写 A 到大写 Z 的字符。 [A-z] 查找任何从大写 A 到小写 z 的字符。 [0-9a-zA-Z] (red|blue|green) 查找任何指定的选项。12var str = &quot;Is this all there is?&quot;;var patt1 = /[a-h]/g;document.write(str.match(patt1));// OUTPUT:h,a,h,e,e 概念：元字符元字符（Metacharacter）是拥有特殊含义的字符： \\ 转义符 （、）、/、\\ | 选择匹配符，可以匹配多个规则 . 查找单个字符，除了换行和行结束符。 \\w 查找单词字符。字符 ( 字母 ，数字，下划线_ ) \\W 查找非单词字符。 \\d 查找数字。 \\D 查找非数字字符。 \\s 查找空白字符。空格 \\S 查找非空白字符。 \\b 匹配单词边界。 \\B 匹配非单词边界。 \\0 查找 NUL 字符。 \\n 查找换行符。 \\f 查找换页符。 \\r 查找回车符。 \\t 查找制表符。 \\v 查找垂直制表符。 \\xxx 查找以八进制数 xxx 规定的字符。 \\xdd 查找以十六进制数 dd 规定的字符。 \\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符。 概念：量词 n+ 匹配任何包含至少一个 n 的字符串。同 {1,} n* 匹配任何包含零个或多个 n 的字符串。同 {0,} n? 匹配任何包含零个或一个 n 的字符串。同 {0,1} n{X} 匹配包含 X 个 n 的序列的字符串。 n{X,Y} 匹配包含 X 至 Y 个 n 的序列的字符串。 n{X,} 匹配包含至少 X 个 n 的序列的字符串。 n$ 匹配任何结尾为 n 的字符串。 ^n 匹配任何开头为 n 的字符串。注意 /[^a] / 和 /^ [a]/是不一样的，前者是排-除的意思，后者是代表首位。 (?=n) 匹配任何其后紧接指定字符串 n 的字符串。正向预查 (?!n) 匹配任何其后没有紧接指定字符串 n 的字符串。反向预查 RegExp 对象方法1.test( )test() 方法检索字符串中是否存在指定的值。返回值是 true 或 false。12345678var patt1 = new RegExp('e');console.log(patt1.test('some text'));// OUTPUT:truevar patt2 = new RegExp('ee');console.log(patt2.test('some text'));// OUTPUT:false// 判断是不是QQ号// 1 首位不能是0 ^[1-9]// 2 必须是 [5, 11] 位的数字 \\d&#123;4, 9&#125;var str = '80583600';var regexp = /^[1-9][0-9]&#123;4,10&#125;$/gim;if (regexp.test(str)) &#123;alert('is');&#125; else &#123;alert('no');&#125; 2.exec( )exec() 方法检索字符串中的指定值。返回值是被找到的值。如果没有发现匹配，则返回 null。123var patt1 = new RegExp('e');console.log(patt1.exec('some text'));// OUTPUT:evar patt2 = new RegExp('ee');console.log(patt2.exec('some text'));// OUTPUT:null 3.compile( )compile() 既可以改变检索模式，也可以添加或删除第二个参数。123var patt1=new RegExp(\"e\");document.write(patt1.test(\"The best things in life are free\")); // true// 改变了检索模式patt1.compile(\"eee\");document.write(patt1.test(\"The best things in life are free\")); // false","tags":[{"name":"RegExp 正则表达式","slug":"RegExp-正则表达式","permalink":"https://liuyu595.github.io/tags/RegExp-正则表达式/"}]},{"title":"node.js--异步逻辑的顺序化","date":"2017-05-21T04:11:38.000Z","path":"2017/05/21/node-js-异步逻辑的顺序化/","text":"摘要：文章对串行化流程和并行化流程做了详细的讲解。正文：在异步程序的执行过程中，有些任务可能随时发生变化，跟程序中的其他部分在做什么没有关系，什么时候做这些任务都不会出问题。异步任务顺序执行的概念被成为流程控制。这种控制分为两类：串行和并行 12345678st=&gt;start: 开始e=&gt;end: 在任务三结束后继续op=&gt;operation: 任务一ox=&gt;operation: 任务二od=&gt;operation: 任务三cond=&gt;condition: st-&gt;op-&gt;ox-&gt;od-&gt;e 并行任务就是说：当任务开始的时候，所有任务同时执行，当所有任务结束之后继续（并行图画不出来～剁手～！！(｡ì _ í｡)）～！ 什么时候使用串行流程控制使用回调让几个异步任务按顺序执行，但是如果任务很多，必须组织以下，否则过多的回调嵌套会把代码高的很乱。下面的代码就是直接用回调让任务按顺序执行的。(^○^)上代码～～！123456789setTimeout(function()&#123;console.log('I execute fist');setTimeout(function()&#123;console.log('I execute next');setTimeout(function()&#123;console.log('I execute last');&#125;,100);&#125;,500);&#125;,1000); 下面用社区贡献的工具实现串行化控制12345678910111213141516171819202122// npm install nimble 安装流程控制工具var flow = require('nimble');//给Nimble 是一个函数数组，让它一个接一个的执行flow.series(&#123;function(callback) &#123;setTimeout(function() &#123;console.log('I execute first.');callback();&#125;,1000);&#125;,function () &#123;setTimeout(function() &#123;console.log('I execute next.');callback();&#125;,500); &#125;,function () &#123;setTimeout(function() &#123;console.log('I execute last.');callback();&#125;,100); &#125;&#125;) 实现串行化流程控制为了有那个串行化流程控制几个异步任务按顺序执行，首先需要把这些任务按照预期执行的顺序放到一个数组。这个数组将起到队列的作用。下面来创建一个例子，用命令行来添加安装辅助模块。 mkdir storycd storynpm install requestnpm install htmlparser requset模块是个经过简化的HPPT客户端，你可以用它获取RSS数据。htmlparser模块能把原始的RSS数据转化成javaScript数据结构。接下来在新目录中新建一个random_story.js文件。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162var fs = require('fs');var request = require('request');var htmlparser = require('htmlparser');var configFilename = './ress_feeds.txt';//1.确保包含RSS预订源URL列表的文件存在function checkForRSSFile ()&#123;fs.exists(configFilename ,function(exists) &#123;if(!exists)//只要有错我就尽早返回return next (new Error('Missing RSS file'+ configFilename));next(null, configFilename)&#125;)；&#125;function readRSSFile (configFilename) &#123;//读取并解析包含预订源URL的文件fs.readFile(configFilename,function(err,feedList)&#123;if(err) return next (err);//将预订源URL列表转换成字符串，然后分割成一个数组feedList = feedList.toString().replace(/^\\s+|\\s+$/g,'').split('\\n');var random = Math.floor(Math.random()*feedList.length);next(null,feedList[random]);&#125;);&#125;function downloadRSSFeed(feedUrl) &#123;//3.向选定的预订源发送HTTP请求以获取数据request (&#123;uri: rendUrl&#125;,function(err,res,body)&#123;if(err) return nex(err);if(res.statusCode !=200)return next(new Error('Abnormal response status code'))next(null,bpdy);&#125;);&#125;function parseRSSFeed (rss) &#123;//4.将预订源数据解析到一个条目数组中var handler = new htmlparser.RssHandler();var parser = new htmlparser.Parser(handler);parser.parseComplete(rss);if (!handler.dom.items.length)return next(new Error('No RSS items found'));var itm = handler.dom.items.shift();//如果有数据，显示第一个预订源条目的标题和urlconsole.log(item.title);console.log(item.link);&#125;//把所有要做的任务按顺序添加到一个数组中var tasks = [checkForRSSFile,readRSSFile,downloadRSSFeed,parseRSSFeed];function next(err,result) &#123;//如果错误，则抛出异常if(err) throw err;//从任务数组中取出下一个任务var currentTask = tasks.shift();if (currentTask) &#123;currentTask(result);&#125;&#125; next(); //开始任务的串行化执行 实现并行化流程控制为了让异步任务并行执行，仍然要把任务放到数组中，但是与串行的流程控制不同，存放的顺序无关紧要。诶个任务都应该调用处理函数增加已完成任务计数。当所有任务都完成后，处理器应该执行后续的逻辑。下面做一个并行化流程控制的例子。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*** Created by liuyu on 2017/5/20.*/var fs = require('fs');var completedTasks = 0;var tasks = [];var wordCounts = &#123;&#125;;var filesDir = './text';function checkIfComplete() &#123;completedTasks++;if (completedTasks == tasks.length) &#123;for (var index in wordCounts) &#123;console.log(index +':'+wordCounts[index]);&#125;&#125;&#125;function countWordsInText(text) &#123;var words = text.toString().toLowerCase().split(/\\W+/).sort();for (var index in words) &#123;var word = words[index];if (word) &#123;wordCounts[word] = (wordCounts[word]) ?wordCounts[word] +1:1;&#125;&#125;&#125;fs.readdir(filesDir,function (err,filse) &#123;if (err) throw err;for(var index in files) &#123;var task = (function (file) &#123;return function () &#123;fs.readFile(file, function (err,text) &#123;if(err) throw err;countWordsInText(text);checkIfComplete()&#125;);&#125;&#125;)(filesDir+'/'+files[index]);tasks.push(task);&#125;for (var task in tasks) &#123;tasks[task]();&#125;&#125;); 附加PS：把所有代码整合到一个文件夹下后，可能意味这被引入文件在执行逻辑会影响全局的作用域。也就是说被引用文件创建的任何变量即生命任何函数都可能会被覆盖包含他的应用程序创建的变量和声明函数。代码分开放置后不会污染全局命名空间。","tags":[{"name":"node","slug":"node","permalink":"https://liuyu595.github.io/tags/node/"}]},{"title":"构建Node Web程序","date":"2017-05-21T04:10:33.000Z","path":"2017/05/21/构建Node-Web程序/","text":"摘要：Node Web程序搭建正文： 搭建简单的静态文件服务器很多的Web程序的需求即使不完全相同也有相似的地方，而静态文件（CSS、JavaScript、图片）服务肯定是其中之一。下面就自己做一个静态文件服务器加深下对Node底层文件系统api。每一个静态文件服务器都有一个根目录，也就是提供文件服务的基础目录。在你即将创建的服务器上定义一个root变量，它将作为我们这个静态文件服务器的根目录：1234567891011var http =require('http');var parse = require('url').parse;//解析var join = require('path').joinvar root =_dirname;var server = http.createSever(function(req,res)&#123;var url = parse(req.url);var path = join(root,url.pathname);&#125;);server.listen(3000); _dirname在node中是一个神奇的变量，他的值是该文件所在目录的路径。_dirname的神奇指出就在于，它在同一个程序中可以有不通的值，如果你有分散在不同的目录中的文件的话。 [注]目录遍历攻击 有了文件路径，还需要传输文件的内容。这个可以用高层流式硬盘访问fs.REadStream完成，它是node中Stream类之一。这个类在从硬盘中读取文件的过程中会发射data事件。1234567891011121314151617181920var http =require('http');var parse = require('url').parse;//解析var join = require('path').joinvar root =_dirname;var server = http.createSever(function(req,res)&#123;var url = parse(req.url);//创建绝对路径var path = join(root,url.pathname);//创建fs.ReadStreamvar stream = fs.createReadStream(path);stream.on('data',function(chunk)&#123;res.write(chunk);&#125;);stream.on('end',function()&#123;res.end();&#125;)&#125;);server.listen(3000); 这个文件服务器基本能能用了，但是缺少细节。接下来优化数据传输，同时精简下代码。 用STREAM.PIPE( )优化数据传输尽管了解fs.ReadStream的工作机制以及它那种方式的灵活性很重要，但是Node还提供了更高级的实现机制：Stream.pipe( )。用这种方法可以极大简化服务器的代码。参考：理解nodejs的stream和pipe机制 node.js处理服务器错误为了服务器不会被error事件抛出后搞垮，都会去监听error事件。像fs.ReadStream这样的流只是专用的EventEmitter,有预先定义data和end等实现，默认情况下，如果没有监听，error事件会被抛出。为了防止服务器没错误搞垮，那么就要去肩痛错误，在fs.ReadStream上祝错一个error事件处理器，返回响应状态码500表明有服务器内部错误：12345stream.pipe(res);stream.on('error',function(err)&#123;res.statusCode = 500;res.end('inrernal Server Error')&#125;) 注册一个error事件处理器，可以不活任何可以遇见或者无法预见的错误。给客户更优雅的响应。 用fs.stat( )实现先发制人的错误处理因为传输的文件是静态的，所以可以可以用stat()系统调用获取文件的相关信息，比如修改时间、字节数。在提供条件GET支持时，这些信息特别重要，浏览器可以发起请求检查它的缓存是否过去。重构后的文件服务器调用了fs.stat( )用于得到文件的相关信息，比如它的大小，或者得到错误码，如果文件不存在，fs.stat会在err.code中放入ENOENT作为响应，然后你可以换回错我吗404，向客户段表明文件没雨找到。如果fs.stat( )换回了其他错误码，可以返回通用的错误码500。12345678910111213141516171819202122232425var server = http.createServer(function(req,res)&#123;var url = parse(req,url);//解析URL以获取路径名var path = join(root,url.pathname);fs.stat(path,function(err,stat)&#123;//检查文件是否存在if(err) &#123;if ('ENOENT' == err.code) &#123;res.statusCode = 404;res.end('NOT Found');&#125;eles &#123;//其他错误res.statusCode = 500;res.end('Internal Sever Error');&#125;else &#123;res.setHeader('Content-Length',stat.size);//用stat对象的属性设置Content-Lengthvar stream = fs.createReadStream(path);stream.pipe(res);stream.on('error',function(err)&#123;res.statusCode = 500;res.end('Internal Server Error')&#125;);&#125;&#125;&#125;);&#125;);","tags":[{"name":"node.js","slug":"node-js","permalink":"https://liuyu595.github.io/tags/node-js/"}]},{"title":"getBoundingClientRect和getClientRects区别及用法","date":"2017-05-18T05:02:57.000Z","path":"2017/05/18/getBoundingClientRect和getClientRects区别及用法/","text":"摘要：详细介绍了getBoundingClientRect和getClientRects区别及用法，以及浏览器兼容性和解决方法。 正文： getClientRects描述 获取元素占据页面的所有矩形区域。 语法 var rectCollection = object.getClientRects(); getClientRects 返回一个TextRectangle集合，就是TextRectangleList对象。TextRectangle对象包含了, top left bottom right width height 六个属性。TextRectangle对象对于文本对象，W3C提供了一个 TextRectangle 对象，这个对象是对文本区域的一个解释。这里的文本区域只针对inline 元素，比如：a, span, em这类标签元素。浏览器差异getClientRects() 最先由MS IE提出，后被W3C引入并制订了标准。目前主流浏览器都支持该标准，而IE只支持TextRectangle的top left bottom right四个属性。IE下可以通过right-left来计算width、bottom-top来计算height。ie 和非ie浏览器在使用getClientRects还是有些差别的，ie获取TextRectangleList的范围很大。而非ie获取的范围比较小， 只有display:inline的对象才能获取到TextRectangleList，例如em i span 等标签。应用场景getClientRects常用于获取鼠标的位置，如放大镜效果。微博的用户信息卡也是通过改方法获得的。 getBoundingClientRectgetBoundingClientRect用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置。getBoundingClientRect是DOM元素到浏览器可视范围的距离（不包含文档卷起的部分）。该函数返回一个Object对象，该对象有6个属性：top,lef,right,bottom,width,height；这里的top、left和css中的理解很相似，width、height是元素自身的宽高，但是right，bottom和css中的理解有点不一样。right是指元素右边界距窗口最左边的距离，bottom是指元素下边界距窗口最上面的距离。下面这是MSDN对document.documentElement.getBoundingClientRect的解释：12345//语法var oRect = object.getBoundingClientRect()return Value//返回一个textrectangle对象。每个矩形都有四个整数属性（上、左、右和下），代表矩形的坐标，以像素为单位。//此方法检索一个对象，该对象将矩形的左、右、下坐标与客户端的左上角相关联。在微软Internet Explorer 5，窗口的左上角是2,2（像素）相对于真正的客户。 getBoundingClientRect()最先是IE的私有属性，现在已经是一个W3C标准。所以你不用当心浏览器兼容问题，不过还是有区别的：IE只返回top,lef,right,bottom四个值，不够可以通过以下方法来获取width,height的值：123456789101112131415161718var ro = object.getBoundingClientRect();var Width = ro.right - ro.left;var Height = ro.bottom - ro.top;//兼容所有浏览器写法：var ro = object.getBoundingClientRect();var Top = ro.top;var Bottom = ro.bottom;var Left = ro.left;var Right = ro.right;var Width = ro.width||Right - Left;var Height = ro.height||Bottom - Top;//有了这个方法，获取页面元素的位置就简单多了:var X= this.getBoundingClientRect().left+document.documentElement.scrollLeft;var Y =this.getBoundingClientRect().top+document.documentElement.scrollTop; getClientRects 和 getBoundingClientRect 的区别返回类型差异：getClientRects 返回一个TextRectangle集合，就是TextRectangleList对象。getBoundingClientRect 返回 一个TextRectangle对象，即使DOM里没有文本也能返回TextRectangle对象.浏览器差异:除了safari，firefox2.0外所有浏览器都支持getClientRects和getBoundingClientRect，firefox 3.1给TextRectangle增加了 width 和 height。 ie 和非ie浏览器在使用getClientRects还是有些差别的，ie获取TextRectangleList的范围很大。而非ie获取的范围比较小， 只有display:inline的对象才能获取到TextRectangleList，例如em i span 等标签。 通过测试，至少Chrome 2+\\Safari 4\\Firefox3.5\\0pera 9.63+已经支持getBoundingClientRect方法。使用场景差异: 出于浏览器兼容的考虑，现在用得最多的是getBoundingClientRect，经常用来获取一个element元素的viewport坐标。","tags":[{"name":"js","slug":"js","permalink":"https://liuyu595.github.io/tags/js/"}]},{"title":"Css Sticky footers 布局的应用","date":"2017-05-18T01:10:48.000Z","path":"2017/05/18/Css-Sticky-footers-布局的应用/","text":"摘要： 预编译正文：问题描述当手机页面高于手机浏览器时，页面中包含定位 position: fixed;时 定位的元素会根据浏览器的显示的区域高度进行定位。问题解决方案Css Sticky footers 布局（粘性页脚布局）粘在底部的意思。可以理解为固定页脚，将页脚固定在底部。需求：1、在内容未撑满页面时，footer固定在底部2、在内容超出页面时，footer随着页面的变大而往下移动，也保持在页面底部。实现的思想：1、header、body、footer都是页面的一部分，page.height = header.height + body.height + footer.height2、footer保持在页面底部，且大小不变，那么header.height + body.height = page.height-footer.height 。3、header,body本身在文档流之内，因此他们的内容可以随意变化，我们将他们看成一个整体，使用一个元素wrapper将他们包裹起来。 wrapper.height = page.height-footer.height4、footer的高度如何知道呢，可以根据设计的时候的设置去推算。由以上看以看出，只需要实时计算出wrapper的高度就可以将footer的位置固定。然而page.height也是可变的，那怎么才能实现呢？这时候就需要使用视窗相对单位。然而有了相对视窗单位的page.height，那怎样动态计算出wrapper.height呢？CSS3中设置了一个计算的calc()函数，浏览器会自动计算。注：由于calc()的兼容性问题，移动端设备大多都不支持。","tags":[{"name":"css","slug":"css","permalink":"https://liuyu595.github.io/tags/css/"}]},{"title":"「Sass」(一)混合、继承、占位符用法区分","date":"2017-05-18T01:08:06.000Z","path":"2017/05/18/「Sass」（一）混合、继承、占位符用法区分/","text":"摘要：什么时候用混合宏，什么时候用继承，什么时候使用占位符？”其实他们各有各的优点与缺点。正文： [Sass]混合宏 、继承、占位符用法区分什么时候用混合宏，什么时候用继承，什么时候使用占位符？”其实他们各有各的优点与缺点。 sass 中混合宏的使用12345678910111213141516171819//SASS中混合宏使用@mixin mt($var)&#123; margin-top: $var; &#125;.block &#123; @include mt(5px); span &#123; display:block; @include mt(5px); &#125;&#125;.header &#123; color: orange; @include mt(5px); span&#123; display:block; @include mt(5px); &#125;&#125; 总结：编译出来的 CSS 清晰告诉了大家，他不会自动合并相同的样式代码，如果在样式文件中调用同一个混合宏，会产生多个对应的样式代码，造成代码的冗余，这也是 CSSer 无法忍受的一件事情。不过他并不是一无事处，他可以传参数。 个人建议：如果你的代码块中涉及到变量，建议使用混合宏来创建相同的代码块。 Sass 中继承123456789101112131415161718.mt&#123; margin-top: 5px; &#125;.block &#123; @extend .mt; span &#123; display:block; @extend .mt; &#125;&#125;.header &#123; color: orange; @extend .mt; span&#123; display:block; @extend .mt; &#125;&#125; 总结：使用继承后，编译出来的 CSS 会将使用继承的代码块合并到一起，通过组合选择器的方式向大家展现，比如 .mt, .block, .block span, .header, .header span。这样编译出来的代码相对于混合宏来说要干净的多，也是 CSSer 期望看到。但是他不能传变量参数。 个人建议：如果你的代码块不需要专任何变量参数，而且有一个基类已在文件中存在，那么建议使用 Sass 的继承。%占位符总结：编译出来的 CSS 代码和使用继承基本上是相同，只是不会在代码中生成占位符 mt 的选择器。那么占位符和继承的主要区别的，“占位符是独立定义，不调用的时候是不会在 CSS 中产生任何代码；继承是首先有一个基类存在，不管调用与不调用，基类的样式都将会出现在编译出来的 CSS 代码中。”12345678910111213141516%mt&#123; margin-top: 5px; &#125;.block &#123; @extend %mt; span &#123; display:block; @extend %mt; &#125;&#125;.header &#123; color: orange; @extend %mt;","tags":[{"name":"css  预编译","slug":"css-预编译","permalink":"https://liuyu595.github.io/tags/css-预编译/"}]},{"title":"vue(一)——组件注册实例子","date":"2017-05-18T01:03:37.000Z","path":"2017/05/18/vue(一）——组件注册实例子/","text":"摘要：组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素， Vue.js 的编译器为它添加特殊功能。以仿饿了么项目为实例：mian.js123456789101112131415161718192021222324252627282930313233343536import Vue from 'vue';import App from './App';//每次添加引入都需要看下相对的webpack文件看下名称import VueRouter from 'vue-router'; import VueResource from 'vue-resource';//组件引入import goods from './components/goods/goods.vue';import ratings from './components/ratings/ratings.vue';import seller from './components/seller/seller.vue';//样式引入import './common/stylus/index.styl';// 下载插件Vue.use(VueRouter);Vue.use(VueResource);let app = Vue.extend(App);let router = new VueRouter(&#123;linkActiveClass:'active'&#125;);//路由创建路径router.map(&#123;'/goods':&#123;component: goods&#125;,'/ratings':&#123;component: ratings&#125;,'/seller':&#123;component: seller&#125;,&#125;);router.start(App,'#app');// go('／页面') 首次加载页面router.go('/goods'); 页面中子组件引入1234//HTML相对应区块写法&lt;div class=&quot;cartcontrol-wrapper&quot;&gt;&lt;cartcontrol :food=&quot;food&quot;&gt;&lt;/cartcontrol&gt;&lt;/div&gt; 12//接收子组件import cartcontrol from 'components/cartcontrol/cartcontrol'; 1234567//抛出组件export default&#123;props: &#123;food: &#123;type: Object&#125;&#125;","tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://liuyu595.github.io/tags/vue-js/"}]},{"title":"移动（手机端）一像素线问题解决方案","date":"2017-04-26T02:40:48.000Z","path":"2017/04/26/移动（手机端）一像素线问题解决方案/","text":"摘要：移动端一像素线，需要定位来解决，使他脱离文档流。 正文:123456789101112.border-1px &#123;position: relative;&#125;.border-1px:after&#123;content: &apos;&apos;;position: absolute;bottom: 0;left: 0;display: block;width: 100%;border-top: 1px solid #ccc;&#125; 新建css文件 &gt; 判断设别像素12345678910111213141516@media(-webikit-min-device-pixel-ratio:1.5),(min-device-pixel-ratio:1.5) &#123;.border-1px &#123;&amp;::after &#123;-webikit-transfrom: scaleY(0.7);transfrom: scaleY(0.7);&#125;&#125;&#125;@media(-webikit-min-device-pixel-ratio:2),(min-device-pixel-ratio:2) &#123;.border-1px &#123;&amp;::after &#123;-webikit-transfrom: scaleY(0.5);transfrom: scaleY(0.5);&#125;&#125;&#125; 补充下，突然想到了样式代码段中有一个content:’’;里面的这个值竟然是空，那么翻阅了大量的资料才知道：在写HTML代码的时候，发现在Firefox等符合W3C标准的浏览器中，如果有一个DIV作为外部容器，内部的DIV如果设置了float样式，则外部的容器DIV因为内部没有clear，导致不能被撑开。这个clearfix的CSS使用了after这个伪对象，它将在应用clearfix的元素的结尾添加content中的内容。在这里添加了一个句号”.”，并且把它的display设置成block；高度设为0；clear设为both；visibility设为隐藏。这样就达到了撑开容器的目的啦。","tags":[{"name":"移动端","slug":"移动端","permalink":"https://liuyu595.github.io/tags/移动端/"}]},{"title":"“《javaScript设计模式与开发实践》（三）”","date":"2017-04-25T02:13:43.000Z","path":"2017/04/25/“《javaScript设计模式与开发实践》（三）”/","text":"摘要：闭包好几天没有更新blog了，虽然没有更新，但是都记录在案了。向雷锋同志学习，记录在本子上。1.1闭包闭包的形成与变量的作用域以及变量的生命周期有关。 1.1变量作用域变量的作用域就是指的变量的有效范围。在声明变量的时候前面没有var的时候，这个变量就会变成全局变量，当然这种做法绒癌造成命名冲突。函数可以用来创造函数的作用域。此时在函数的作用域中声明的变量都是局部变量，自由在函数体中，才能访问的到。1.2变量的生命周期除了变量之外，另外根闭包有关的还有就是变量的生命周期。对于全局变量来说生命周期是永久的，除非我们主动的销毁这个全局变量。对于局部变量来说，当退出函数时，这些局部变量及失去了它们的价值，他们都会随着函数调用的结束而被销毁。锯割栗子12345var func =function()&#123;var a = 1; //退出函数后局部变量a销毁alert(a);&#125;func(); 1.3闭包的作用 封装变量 延续局部变量的寿命闭包是如何延续寿命的呢？锯割栗子:1234567//img对象经常用于进行数据上报。var img = function(src)&#123;var img = new Imge();img.src=src; &#125;;report('hettp://baidu/com') ;//版本低的实现存在bug 分析下这个原因： 数据在请求时丢失数据，原因是因为函数中的局部变量当函数被调用时，img局部变量随机呗销毁了，所以这时的http请求没有来的发出，所以就会出现请求丢失。 解决问题的办法：12345678var report = function(function()&#123;var imgs = [];return function (src) &#123;var img = new Image();imgs.push(img);img.src =src;&#125; &#125;)();","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://liuyu595.github.io/tags/设计模式/"}]},{"title":"“项目开发问题总结（一）”","date":"2017-04-25T02:02:20.000Z","path":"2017/04/25/“项目开发问题总结（一）”/","text":"摘要： 基于bootstrap响应式开发后台兼容多种平台——后台管理系统 总结近期项目中的遇见到的问题和解决方法 公司自己的项目要做到快速开发，一个月实现所有功能。一个前端的我有点苦逼。pc和移动端兼容，那么就选择框架喽～需求兼容ie8。 一、框架因为要快速开发移动端和pc端，尽量减少页面重复去写，那么就用bootstrap吧。简单高效一套代码解决战斗。（(｡ì _ í｡) 现实永远是打脸的，啪啪啪～！）。 二、项目内容pc端的页面比较好整，因为有大量的表格用bootstrap-table插件，兼容ie8。效率也是比较高的，自带封装ajax异步请求。那么现在说下移动端（( ´▽｀)这个表情估计能表达我内心的万马奔腾～！），因为有个中表格，表格里面有很多内容，还有很多对列表的操作，所以移动端页面为了好看，还是要重构。 三、问题和解决办法安卓： INPUT表格获取焦点后，软键盘弹出遮盖表单。页面功能描述 登陆页面：input表单比较少，所以可以采取定位的方式进行，这样简单的两行js就可以搞定，这是方法一：123456$(\"input\").focus(function()&#123;$(\".center\").css(\"position\",\"fixed\");$(\".center\").css(\"left\",\"50%\");$(\".center\").css(\"top\",\"50%\");$(\".center\").css(\"transform\",\"translate(-50%,-50%)\");&#125;); 方法二：对于表格比较多的页面来说，就用scrollTop() 这个方法:1$(&quot;class&quot;).scrollTop(**计算后填写需要滚动高度**)","tags":[{"name":"开发项目 问题总结","slug":"开发项目-问题总结","permalink":"https://liuyu595.github.io/tags/开发项目-问题总结/"}]},{"title":"庐山游记","date":"2017-04-18T13:46:39.000Z","path":"2017/04/18/庐山游记/","text":"","tags":[{"name":"游记","slug":"游记","permalink":"https://liuyu595.github.io/tags/游记/"}]},{"title":"node.js雪崩问题","date":"2017-04-06T07:34:37.000Z","path":"2017/04/06/node-js雪崩问题/","text":"雪崩问题的产生雪崩问题的产生是由于在计算机中的缓存存放在内存中，访问速度非常的快，常常加速数据的访问，让绝大多数的数据请求不被重复去做一些低级的数据读取。如果这时访问量大，高并发的情况下缓存容易失效，此时大量的请求同时涌入数据库中，数据库无法同时承受如此大的查询量。进而影响整个网站的额响应速度。正文：12345var select = function (callback)&#123;db.select (\"SQL\",function(results)&#123;callback(results)&#125;)&#125; 如果站点刚刚启动，这时缓存中是不存在数据的，而访问量很大，同时执行同一句的SQL会被发送到数据库中反复查询。改进方法一：添加一个状态锁。123456789var status = \"ready\";var select = function(callback)&#123;if (status === \"ready\")&#123;status = \"pending\" ;db.select(\"SQL\",function(results)&#123; status = \"ready\";callback(results);&#125;)&#125;&#125; 但是在这种情况下会连续多次调用select( )时，只调用第一次的请求。（能不能用闭包处理此方法呢？～我也不知道，等什么时候不忙了，在研究这个问题吧～！大概想了下这个问题，感觉蛮麻烦的。）利用时间队列解决雪崩问题在订阅发布事件模式中，有一个once（）方法，通过它添加的监听器还能执行一次，执行之后，就会与实践的关联移除。这个特性可以帮我们过滤一些重复性的请求问题。123456789101112var proxy = new events.EvenEmitter();var status = \"ready\";var select = function (callback)&#123;proxy.once(\"selected\",callback);if(status === \"ready\")&#123;status = \"pending\";db.select(\"SQL\",function (results)&#123;proxy.emit(\"selected\",results);status = \"ready\";&#125;)&#125;&#125;","tags":[{"name":"node","slug":"node","permalink":"https://liuyu595.github.io/tags/node/"}]},{"title":"node.js之mongoDB数据库连接思路","date":"2017-04-05T04:35:04.000Z","path":"2017/04/05/node-js之mongoDB数据库连接思路/","text":"一入程序深似海，从此美妞儿是路人。假期三天结束了，哪里都没有去，安心在家学习充电。一切的一切：为了小钱钱～！（耿直的微微一笑）————致种花家：《那兔》 先上代码：12345678910111213141516171819202122232425var MongoClient = require('mongodb').MongoClient;var DB_CONN_STR = 'mongodb://localhost:27017/runoob';var insertData = function(db, callback) &#123;//连接到表 sitevar collection = db.collection('site');//插入数据var data = [&#123;\"name\":\"菜鸟教程\",\"url\":\"www.runoob.com\"&#125;,&#123;\"name\":\"菜鸟工具\",\"url\":\"c.runoob.com\"&#125;];collection.insert(data, function(err, result) &#123;if(err)&#123;console.log('Error:'+ err);return;&#125;callback(result);&#125;);&#125;;MongoClient.connect(DB_CONN_STR, function(err, db) &#123;console.log(\"连接成功！\");insertData(db, function(result) &#123;console.log(result);db.close();&#125;);&#125;); 如果单独执行这个命令会报错的，原因是因为没有安装依赖模块“mongodb”。 $ npm install mongodb 这个是一定要安装的。 好啦~代码分析开始： 声明一个变量引入并监听mongo模块。 声明一个变量连接本地数据库mongodb://localhost:27017/runoob。 创建回调函数。 在函数体内声明一个变量连接到表（ps:这点做了个实验，当这个表没有的时候会自己创建一个新表，然后自动插入数据）。 声明一个变量，传入数组。 监听数据库是否连接成功。","tags":[{"name":"node、数据库","slug":"node、数据库","permalink":"https://liuyu595.github.io/tags/node、数据库/"}]},{"title":"brew安装mongoDB下的坑","date":"2017-04-02T02:49:46.000Z","path":"2017/04/02/brew安装mongoDB下的坑/","text":"今天放假三天，趁此机会向着大前端迈进～！大刀阔斧～！欣喜若狂～！终于装上mongoDB了～！运行了下！启动失败了～！（有点小失落，虽然对于新的东西刚刚接触后总会出现点小问题。） MongoDB shell version v3.4.3connecting to: mongodb://127.0.0.1:270172017-04-02T10:43:39.099+0800 W NETWORK [thread1] Failed to connect to 127.0.0.1:27017, in(checking socket for error after poll), reason: Connection refused2017-04-02T10:43:39.101+0800 E QUERY [thread1] Error: couldn’t connect to server 127.0.0.1:27017, connection attempt failed :connect@src/mongo/shell/mongo.js:237:13@ (connect):1:6exception: connect failed 启动失败了，遇到这个原因纠结了一上午时间终于找到了结决的办法了。 先说下问题出现的原因：当mongodb service 没有运行的时候会发生这样的错误。最后找到了如下方法解决然后 在bash 输入 brew services start mongodbmongo //进入数据库回车后成功了～！ liuyudeMBP:~ liuyu$ mongoMongoDB shell version v3.4.3connecting to: mongodb://127.0.0.1:27017MongoDB server version: 3.4.3Welcome to the MongoDB shell.For interactive help, type “help”.For more comprehensive documentation, seehttp://docs.mongodb.org/Questions? Try the support grouphttp://groups.google.com/group/mongodb-userServer has startup warnings:2017-04-02T10:46:51.655+0800 I CONTROL [initandlisten]2017-04-02T10:46:51.655+0800 I CONTROL [initandlisten] WARNING: Access control is not enabled for the database.2017-04-02T10:46:51.655+0800 I CONTROL [initandlisten] Read and write access to data and configuration is unrestricted.2017-04-02T10:46:51.655+0800 I CONTROL [initandlisten]^Cbye","tags":[{"name":"mongoDB","slug":"mongoDB","permalink":"https://liuyu595.github.io/tags/mongoDB/"}]},{"title":"《javaScript设计模式与开发实践》（二）","date":"2017-03-30T00:58:51.000Z","path":"2017/03/30/《javaScript设计模式与开发实践》（二）/","text":"categories: JS这本说写的真的不错，有食欲让我细细品味。下面来探究下call 和applyECAMScript3 给Function的原型定义了两个方法，Function.prototype.call 和Function.portotype.apply在js社基本模式中这两个方法应用非常广泛。 call和apply的区别两个方法其实作用是一样的，只是区别于传参的形式不同。apply接受两个参数，一个参数指定函数体内的this对象的指向，第二个参数为一个下标的集合，这个集合可以是数组，可以是类数组，把这个集合中的元素作为参数传递给被调用的函数。call跟上面基本一样，同样第一个参数指定this对象，第二个参数是依次传递。 锯割栗子 var func = function(a,b,c){alert( [a,b,c]); //输出 123 } func.apply( null,[1,2,3]) call和bind都有一个同样的功能就是矫正this指向问题。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://liuyu595.github.io/tags/设计模式/"}]},{"title":"鼠标拖动玩一玩","date":"2017-03-29T14:27:04.000Z","path":"2017/03/29/鼠标拖动玩一玩/","text":"摘要： 鼠标拖动封装 123456789101112131415161718192021222324252627$(function()&#123;//定义拖拽obj=$(\"#div1\");drag(obj);&#125;)function drag()&#123;obj.bind(\"mousedown\",start); //第一个是时间名 第二个是函数名function start(event)&#123; //事件触发后 产生的eventdeltaX=event.clientX-obj.offset().left;deltaY=event.clientY-obj.offset().top;$(document).bind(\"mousemove\",move);$(document).bind(\"mouseup\",stop);return false;&#125;function move()&#123;obj.css(&#123;\"left\":(event.clientX-deltaX)+\"px\",\"top\":(event.clientY-deltaY)+\"px\"&#125;)return false;&#125;function stop()&#123;$(document).unbind(\"mousemove\",move);$(document).unbind(\"mouseup\",stop);&#125;&#125;","tags":[{"name":"dome","slug":"dome","permalink":"https://liuyu595.github.io/tags/dome/"}]},{"title":"《javaScript设计模式与开发实践》（一）","date":"2017-03-29T01:05:00.000Z","path":"2017/03/29/《javaScript设计模式与开发实践》（一）/","text":"题外话：新书到了，今天试着读了下写的很不错的一本书（感谢彭彭推荐的好书）；其实很喜欢里面的一句话，程序改的越多出错的几率越大，是呀～！一点没错 第一部分面向对象的javaScript1.1动态类型语言和鸭子语言动态语言类型的优点：代码简单，看起来更简洁，但是区分不清类型的情况下会使得代码更难理解，但整体来说，代码量越少越可以多专注于逻辑。动态语言类型的缺点就是没有办法保证变量的类型。在javascript中对一个变量赋值时是不用考虑她的类型，显然javascript是一门动态语言。一切都建立在鸭子类型的基础之上，鸭子类型通俗理解就是“如果它走起路来像鸭子，叫起来也是鸭子，那么就是鸭子”，即便其中掺加入的有狗，但是狗的叫声是鸭子叫声那么他就是鸭子。1.2 多态多态的含义：同一个操作用与不同的对象上面，可以产生不同的解释和不同的执行结果。换句话说我们所写的if语句就是多态的形式。多态背后的思想就是将“做什么”和“谁去做”分离出来。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://liuyu595.github.io/tags/设计模式/"}]},{"title":"杂谈（一）","date":"2017-03-26T13:24:51.000Z","path":"2017/03/26/杂谈（一）/","text":"摘要：翻开自己的笔记本看到了这篇文章，写于2015年农历八月十五。现在回想一下也不知道是什么情况下写的了。剩下的只有莫名的伤感。正文：港囧，一部自己感觉很纠结的片子。等了20年就是为了证明我的青春岁月真实的存在过。 15岁觉得游泳难，放弃游泳，到18岁遇到一个你喜欢的人约你去游泳，你只好说“我不会耶”。18岁觉得英文难，放弃英文，28岁出现一个很棒但要会英文的工作，你只好说“我不会耶”。人生前期越嫌麻烦，越懒得学，后来就越可能错过让你动心的人和事，错过新风景。 怎样度过人生的低潮期？安静地等待；好好睡觉；锻炼身体，无论何时好的体魄都用得着；和知心的朋友谈天，基本上不发牢骚，主要是回忆快乐的时光；多读书，看一些传记，增长知识，顺带还可瞧瞧别人倒霉的时候是怎么挺过去的；趁机做家务，把平时忙碌顾不上的活儿都干完。 有时候，我们放不开不是因为失去，而是心疼自己的付出。 以前我总是习惯焦虑，每次都期望有人指明我要走的路，可人终究是孤独的，每个人的人生都有别人参与，却都要自己完成。现在我已经学会面对和接受孤独，即使伤疤没磨练的足够硬实，也不再依赖别人给的铠甲。恩，孤独的人，都会很快长大。 一座城市令你念念不忘，大抵是因为，那里有你深爱的人和一去不复返的青春。 成长的很大一部分，是接受。接受分道扬镳，接受世事无常，接受孤独挫折，接受突如其来的无力感，接受自己的缺点。然后发自内心地去改变，找到一个平衡点。跟世界相处，首先是和自己相处。天黑开盏灯，落雨带把伞，难过归难过，但也不作死。 如果你感到委屈，证明你还有底线；如果你感到迷茫，证明你还有追求；如果你感到痛苦，证明你还有力气；如果你感到绝望，证明你还有希望。从某种意义上，你永远都不会被打倒，因为你还有你。 无论贫穷还是富足，开心的人最令人羡慕。 有时像患了忧郁症一样，会突然心情不好。 偶尔像患了自闭症似的，不想说话也不想动。别人问起，也不知道该怎样回答。不是假装沉默，只是无力诉说。或许每个人都有一个死角，自己走不出来，别人也闯不进去，我把最深沉的秘密放在那里，你不懂我，我不怪你。 比起并肩、牵手、接吻、很多人最喜欢的应该还是拥抱吧。当你用双臂紧紧把一个人抱在怀里时，没什么比那更能让人体会到什么叫做拥有了。 感谢时光，不偏不倚，躲过了风口浪尖，让我恰好遇见你。","tags":[{"name":"感悟","slug":"感悟","permalink":"https://liuyu595.github.io/tags/感悟/"}]},{"title":"Three.js之小白入坑（一）","date":"2017-03-22T15:31:31.000Z","path":"2017/03/22/Three-js之小白入坑（一）/","text":"摘要：首先要感谢仙女姐姐早期发表在图灵的文章，通俗易懂，介于对这位女神的崇拜，我会认真的读下去。 正文：初识回眸一笑百媚生，六宫粉黛无颜色，初次见到是再某猫是双十二购物狂欢节的APP上，第二次见到是快过年的时候，某猫倒计时春节的一个动画。以至于一见倾心。 入坑——照相机废话不多说，带好自己的铁锹、锄头、手电筒（自己都感觉有点挖坟掘墓的节奏）。什么是照相机这个照相机值得是在图形学中的照相机，比较抽象。这里的照相机就是把三维空间头型到二维屏幕的一个方式（可以脑补下，我们在纸上画空间立体直角坐标系一样一样的）。而针对投影方式的不同，相机又分为正交投影照相机喝透视投影照相机。正交照相机蒸饺投影相机（orthogtaphic camera）设置起来比较直观哈，它的构造函数：1THREE.OrthographicCamera(left, right, top, bottom, near, far) //开头必须大写 http://wx2.sinaimg.cn/mw690/006qXO9qly1fdw1mjbntfj30jg0hkgmd.jpg 注意：为了保持照相机的横竖比例，需要保证(right - left)与(top - bottom)的比例与Canvas宽度与高度的比例一致。near与far都是指到照相机位置在深度平面的位置，而照相机不应该拍摄到其后方的物体，因此这两个值应该均为正值。为了保证场景中的物体不会因为太近或太远而被照相机忽略，一般near的值设置得较小，far的值设置得较大，具体值视场景中物体的位置等决定。下面是关键词，当在有问题需要查帮助文档时 直接搜索关键词：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189Cameras（照相机，控制投影方式）CameraOrthographicCameraPerspectiveCameraCore（核心对象）BufferGeometryClock（用来记录时间）EventDispatcherFace3Face4GeometryObject3DProjectorRaycaster（计算鼠标拾取物体时很有用的对象）Lights（光照）LightAmbientLightAreaLightDirectionalLightHemisphereLightPointLightSpotLightLoaders（加载器，用来加载特定文件）LoaderBinaryLoaderGeometryLoaderImageLoaderJSONLoaderLoadingMonitorSceneLoaderTextureLoaderMaterials（材质，控制物体的颜色、纹理等）MaterialLineBasicMaterialLineDashedMaterialMeshBasicMaterialMeshDepthMaterialMeshFaceMaterialMeshLambertMaterialMeshNormalMaterialMeshPhongMaterialParticleBasicMaterialParticleCanvasMaterialParticleDOMMaterialShaderMaterialSpriteMaterialMath（和数学相关的对象）Box2Box3ColorFrustumMathMatrix3Matrix4PlaneQuaternionRaySphereSplineTriangleVector2Vector3Vector4Objects（物体）BoneLineLODMesh（网格，最常用的物体）MorphAnimMeshParticleParticleSystemRibbonSkinnedMeshSpriteRenderers（渲染器，可以渲染到不同对象上）CanvasRendererWebGLRenderer（使用WebGL渲染，这是本书中最常用的方式）WebGLRenderTargetWebGLRenderTargetCubeWebGLShaders（着色器，在最后一章作介绍）Renderers / RenderablesRenderableFace3RenderableFace4RenderableLineRenderableObjectRenderableParticleRenderableVertexScenes（场景）FogFogExp2SceneTextures（纹理）CompressedTextureDataTextureTextureExtrasFontUtilsGeometryUtilsImageUtilsSceneUtilsExtras / AnimationAnimationAnimationHandlerAnimationMorphTargetKeyFrameAnimationExtras / CamerasCombinedCameraCubeCameraExtras / CoreCurveCurvePathGyroscopePathShapeExtras / Geometries（几何形状）CircleGeometryConvexGeometryCubeGeometryCylinderGeometryExtrudeGeometryIcosahedronGeometryLatheGeometryOctahedronGeometryParametricGeometryPlaneGeometryPolyhedronGeometryShapeGeometrySphereGeometryTetrahedronGeometryTextGeometryTorusGeometryTorusKnotGeometryTubeGeometryExtras / HelpersArrowHelperAxisHelperCameraHelperDirectionalLightHelperHemisphereLightHelperPointLightHelperSpotLightHelperExtras / ObjectsImmediateRenderObjectLensFlareMorphBlendMeshExtras / Renderers / PluginsDepthPassPluginLensFlarePluginShadowMapPluginSpritePluginExtras / ShadersShaderFlaresShaderSprite 透视相机透视相机参数的构造函数： THREE.PerspectiveCamera(fov, aspect, near, far)透视图中，灰色的部分是视景体，是可能被渲染的物体所在的区域。fov是视景体竖直方向上的张角（是角度制而非弧度制），如侧视图所示。 aspect等于width / height，是照相机水平方向和竖直方向长度的比值，通常设为Canvas的横纵比例。 near和far分别是照相机到视景体最近、最远的距离，均为正值，且far应大于near。","tags":[{"name":"Three.js","slug":"Three-js","permalink":"https://liuyu595.github.io/tags/Three-js/"}]},{"title":"ES6入门笔记（四）","date":"2017-03-19T15:17:52.000Z","path":"2017/03/19/ES6入门笔记（四）/","text":"摘要：Promise 正文： Promise:——承诺这是个什么鬼？大概看了下往上对于这个东西神话已经的评论！看来面对这个东西是一场硬仗～！感觉到了千军万马，只有我只身一人～！只待我上阵杀敌挥起大刀砍杀时，说时迟那时快，手起刀落才知道——尼玛他就是个Promise对象。这个对象主要来传递异步操作的数据（消息），这个对象规定了三种状态： pending(等待／处理中)—&gt;Resolve(完成／fullfilled)—&gt;rejected(拒绝／失败)这样的处理方式能使得ajax异步请求更加的完美；","tags":[{"name":"ES6","slug":"ES6","permalink":"https://liuyu595.github.io/tags/ES6/"}]},{"title":"ES6Tab选项卡、轮播图","date":"2017-03-15T14:27:07.000Z","path":"2017/03/15/ES6Tab选项卡、轮播图/","text":"摘要：ES6 面向对象编程——选项卡、轮播图 正文： es6面向对象——选项卡、轮播直接荔枝（今天心情不错，换个果子） 样式部分 1234567.on&#123;background:#f60;color:#fff&#125;.box div&#123;width:200px;height:200px;border:1px red solid;display:none;&#125; heml部分12345678910111213141516&lt;div id=\"box\" class=\"box\"&gt;&lt;input class=\"on\" type=\"button\" value=\"aaa\"&gt;&lt;input type=\"button\" value=\"bbb\"&gt;&lt;input type=\"button\" value=\"ccc\"&gt;&lt;div style=\"display: block\"&gt;111&lt;/div&gt;&lt;div&gt;222&lt;/div&gt;&lt;div&gt;333&lt;/div&gt;&lt;/div&gt;&lt;div id=\"box2\" class=\"box\"&gt;&lt;input class=\"on\" type=\"button\" value=\"aaa\"&gt;&lt;input type=\"button\" value=\"bbb\"&gt;&lt;input type=\"button\" value=\"ccc\"&gt;&lt;div style=\"display: block\"&gt;111&lt;/div&gt;&lt;div&gt;222&lt;/div&gt;&lt;div&gt;333&lt;/div&gt;&lt;/div&gt; js部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Tab&#123;constructor(id)&#123;this.oBox=document.getElementById(id);this.aBtn=this.oBox.getElementsByTagName('input');this.aDiv=this.oBox.getElementsByTagName('div');this.iNow=0;this.init();&#125;init()&#123;for(let i=0; i&lt;this.aBtn.length; i++)&#123;this.aBtn[i].onclick=function()&#123;// alert(i);// alert(this);this.hide();this.show(i);&#125;.bind(this); //bind矫正this指向&#125;&#125;hide()&#123;for(let i=0;i&lt;this.aBtn.length;i++)&#123;this.aBtn[i].className=\"\";this.aDiv[i].style.display='none';&#125;&#125;show(index)&#123;this.aBtn[index].className=\"on\";this.aDiv[index].style.display='block';&#125;&#125;//继承class AutoTab extends Tab&#123;//constructor(id)&#123;super(id);//alert(111);//setInterval(this.next,1000); this 指向objsetInterval(this.next.bind(this),1000);&#125;next()&#123;this.iNow++;if(this.iNow==this.aBtn.length)this.iNow=0;this.hide();this.show(this.iNow);&#125;&#125;window.onload=function()&#123;new Tab('box');var at=new AutoTab(\"box2\");&#125;","tags":[{"name":"ES6语法","slug":"ES6语法","permalink":"https://liuyu595.github.io/tags/ES6语法/"}]},{"title":"ES6入门笔记（三）","date":"2017-03-14T06:17:47.000Z","path":"2017/03/14/ES6入门笔记（三）“/","text":"箭头函数、面向对象、继承。 正文： 箭头函数 =&gt;不多说直接一个栗子：12345678window.onload=()=&gt;&#123;var oBox=document.getElementById(\"box\");oBox.onclivk=()=&gt;&#123;//alert(this);//这时这里的this指的是window,所有没有办法this.styleoBox.style.background=\"red\";&#125;;&#125;; 1&lt;div id=\"box\"&gt;&lt;/div&gt; 注意：1、 this的问题,指向window；2、箭头函数中arguments,不能使用。 对象：es6对象作了简化单体模式直接简单粗暴上举板栗： 12345678910111213var name='abb';var age=111;var preson=&#123;name,age,showName()&#123;return this.name;&#125;,showName()&#123;return this.age;&#125;&#125;;alert( preson.showName() ); 面向对象es6之前123456789101112function Person(name,age)&#123;this.name=name;this.age=age;&#125;Person.prototype.showName=function()&#123;return this.name;&#125;;Person.prototype.showName=function()&#123;return this.name;&#125;;var p1=new Person(\"abc\",101);alert(p1.showName()); 上面这样写不是真的面向对象，这里的这个东西又是类又是构造函数。es6在面向对象上面做了一个彻底的区分，什么是构造函数？构造函数简单的说就是生成实例以后，自己就执行的函数。1234567891011121314151617来吧～！锯割栗子：```javascriptclass Person&#123; //类constructor(name,age)&#123;this.name=name;this.age=age;&#125;showName()&#123;return this.name;&#125;showAge()&#123;return this.age;&#125;&#125; 函数给默认值1234function move(obj=\"对象必须要填写\"，json=&#123;&#125;)&#123;console.log(options);&#125;move(); 继承之前的继承，来再锯割栗子：1234567function Worker(name,age)&#123;Person.apply(this,arguments);&#125;Worker.prototype=new Person();var w1=new Person('ddd',20);alert(p1.showName());//之前的继承模式：子类.prptotype=new 父类（）； es6中的继承123456789function Worker(name,age)&#123;Person.apply(this,arguments);&#125;//继承开始class Worker extends Person&#123;&#125;var w1=new Worker('mmm',34);alert(w1.showAge()); //34 es6继承中的super锯割栗子：（今天晚上很暴力的吃了好的坚果）1234567891011121314151617181920212223242526class Person&#123;constructor(name='add',age=0)&#123;this.name=name;this.age=age;&#125;showName()&#123;return this.name;&#125;showAge()&#123;return this.age;&#125; &#125;//继承开始class Worker extends Person&#123;constructor(name,age,job=\"刷马桶\")&#123;//这样写之后，之前的父级的构造函数被覆盖掉了为了不被覆盖掉那么我们就用super.//this.job=job; //definedsuper(name,age);this.job=job&#125;showJob()&#123;return this.job;&#125;&#125;var w1=new Worker('mmm',34); 每天多学一点，明天就少写一行代码～！","tags":[{"name":"ES6语法","slug":"ES6语法","permalink":"https://liuyu595.github.io/tags/ES6语法/"}]},{"title":"hexo之入门后填坑(一)","date":"2017-03-13T01:26:51.000Z","path":"2017/03/13/hexo之入门后填坑（一）/","text":"摘要：本文主要说下markdown的语法，编译器。 正文:对于一个新手小白，真的是一坑到底的节奏了。欲哭无泪跳坑吧～！科普下吧：Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 代码块 +「脚本语言名称全拼」+代码内容+```结束12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 表格语法格式12345| Item | Value | Qty || :-------- | --------:| :--: || Computer | 1600 USD | 5 || Phone | 12 USD | 12 || Pipe | 1 USD | 234 | ``` markdown编译器： 推荐 sublime :轻量级编译器功能强大，不具有实时显示编辑文本功能。不建议新手使用。 推荐 马克飞象 :之前一直用印象笔记去记录代码总结，马克飞象是支持Chrome的同样可以绑定到印象笔记，具备实时编辑文本功能。推荐新手使用。","tags":[{"name":"hexo","slug":"hexo","permalink":"https://liuyu595.github.io/tags/hexo/"}]},{"title":"ES6入门笔记（二）","date":"2017-03-12T06:17:47.000Z","path":"2017/03/12/ES6入门笔记（二）/","text":"摘要： 复制数组————spread、Map、for-of循环 正文： 数组复制 举栗子 12345var arr = [1,2,3];var arr2=arr;arr2.pop();console.log(arr, arr2);//arr2删除最后一个元素时，arr也会受到影响 怎么才能不让我们的arr受到牵连呢？ 再举一栗子—–循环 1234567var arr = [1,2,3];var arr2=[];for(var i=0; i&lt;arr.length; i++)&#123;arr2[i]=arr[i];&#125;console.log(arr, arr2);//arr这时候是不会受到任何影响的；但是这种方法比较繁琐； 下面在举一个板栗吧～！ 12345var arr = [1,2,3];var arr2=Array.from(arr);arr2.pop();console.log(arr, arr2);//这个板栗还是可以的，简单多了； 科普下Array.from( ) es6 新特性中 Array 类多了一个静态方法 from ，这个方法作用是将一个 ArrayLike 对象或者 Iterable 对象转换成一个 Array。所谓 ArrayLike 对象指具有数组某些行为的对象，表现出来的特征就是具有 length 属性。 1234var obj = &#123;\"0\" : 1,length: 1&#125;; 这一类对象不能调用数组所具有的方法(push/forEach/map之类)，最常见的有两种：DOM中的 NodeList 和函数中的 arguments 。在平常开发中，我们经常遇到需要将这两种对象转化为真正数组的场景，一般我们是这么写： 12var args = [].slice.call(arguments);var imgs = [].slice.call(document.querySelectorAll('img')); 现在有了Array.from后我们可以这样写： 123var args = Array.from(arguments);var imgs = Array.from(document.querySelectorAll('img'));//不考虑兼容性的时候我们可以这样写 下面言归正传吧：接着写我们的数组～接着举例子！ 新鲜板栗来了～！好吃不贵1234var arr = [1,2,3];var arr2=[...arr];arr2.pop();//前面的这三个点——“超引用”这么叫吧 123456function show(...args)&#123;args.push(5);console.log(args);&#125;show(1,2,3,4)//完美解决 ##循环 es6新增了一个 for of 循环，那么这个循环的目的：是遍历（迭代、循环）这个对象，表现有点类似for in。但是不能循环json,其真正的目的是循环 map对象的。 来个代码看看吧1234var arr=['apple','banana','orange','pear'];for(var i of arr)&#123;console.log(i);&#125; 注：上述打印出来的结果跟普通的for in 打印出来的结果不一样，for in打印出来是数组的下标，而for of 打印出来却是相对应的水果名字。 Map对象map对象和json相似，也是一种key-value形式，Map对象为了和for of 循环为何而生。 语法123456789101112131415var map =new Map（）；//设置：map.set(name,value);//获取map.set('a','apple');map.set('b','banana');//console.log(map.a);//alert(map.a); undefined//获取map就用get（）方法alert(map.get('a'))//删除delete map.a; //json 删除方法在这里没有效果map.delete('a'); //map的delete方法，可以用的 map和for of结合去用：123456789var map =new Map();map.set('a','apple');map.set('b','banana');map.set('c','orange');map.set('d','pear');for(var [key,value] of map)&#123;console.log(key,value);//[key,value]中两个参数可以是任何字母&#125; 1234for(var [key,value] of map)&#123;console.log(key,value);//这时map的默认值是enteries,也就是map.enteries( ),&#125; 单独获取a b c d 12345678910var map =new Map();map.set('a','apple');map.set('b','banana');map.set('c','orange');map.set('d','pear');for(var key of map.keys())&#123;console.log(key);&#125;//循环val 同理","tags":[{"name":"ES6语法","slug":"ES6语法","permalink":"https://liuyu595.github.io/tags/ES6语法/"}]},{"title":"”ES6入门笔记（一）“","date":"2017-03-12T03:03:33.000Z","path":"2017/03/12/ES6入门笔记（一）“/","text":"摘要： 之前我们接触到的js主要是由ECMA DOM BOM组成的。ES6就是之前的一个版本的迭代。 ECMA是标准，JS是实现者；换句话说还有可能有其他的版本来实现ECMA. 目前浏览器：主要分为两种一个是高级低级浏览器：主要支持ES3.1;高级浏览器正在从ES5到ES6过度。 正文: 直接在node里面使用： 1.直接用，需要在相应的js文件中头部添加‘ues strict’; 2.nede –harmony_destructuring xxx.js; 定义变量——let(目前位置已经被浏览器支持，不用引入js)； 代码块：{}包起来的代码叫代码块； 例如：{ let a=12; alert(a); //是可以在浏览器中拿到的 } alert(a)//这里的这个a 在浏览器中是不能被拿到的。 所以用{}包起来后就形成了一个作用域，这个作用域之能在相应的块中实现； let 声明的变量与 var声明的变量不同的是，var只有在函数体中才有作用域，而let与此不同； 封闭空间的问题： 之前用var声明一个变量的时候： for(var i=; i&lt;aBtn.length; i++){ (function(i){ aBtn[i].onclick=function(){ alert(i); } })(i); }; // 这样写的原因是var 没有一个封闭空间所以要用一个自运行函数在包裹它； 那么现在的let 是什么样子呢？for(let i=0; i&lt;aBtn.length;i++){ aBtn[i].onclick=function(){ alert(i);} 如果出现了一个大组件怎么办呢？怎么办呢？怎么办呢～！逗比呢？不是有const来定义敞亮么？常量一旦赋值就没有办法再修改了呀～！ ———————————————————————————————— 下面说下字符串链接：（个人感觉没有什么区别，估计是之前用习惯了吧） 反单引号 字符串模版 ： var str=`` 这两个单引号就是 数字1键前面的那个东西～ ·阿斯顿$(变量名)风格化` ———————————————————————————————— 解构赋值：var [a,b,c]=[12,3,5] 那么json的解构赋值就是：var {a,b,c}={a:2,b:3,c:3}; 注意：解构赋值时 要对应名字～！！！！切记～切记～！ 模式匹配：——————左边和右边的样式一样 var [a,[b,c],d]=[12,[1,2],5]; 此外补充一点解构赋值是可以给默认值的： 语法：var {time=12,id=0}={} 然而之前的方法是这样的：var json={}; var a=json.a||12 今天就到此为止吧～ 还是那句话，每天多学一点，就能少打一行代码～！","tags":[{"name":"ES6语法","slug":"ES6语法","permalink":"https://liuyu595.github.io/tags/ES6语法/"}]},{"title":"放眼看世界","date":"2017-03-09T03:42:59.000Z","path":"2017/03/09/see-word/","text":"摘要： 测试第一个博客文章正文：走自己的路，让别人羡慕","tags":[{"name":"放眼看世界 世界都亮了","slug":"放眼看世界-世界都亮了","permalink":"https://liuyu595.github.io/tags/放眼看世界-世界都亮了/"}]},{"title":"Hello World","date":"2017-03-09T02:49:02.000Z","path":"2017/03/09/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]