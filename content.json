[{"title":"node.js雪崩问题","date":"2017-04-06T07:34:37.000Z","path":"2017/04/06/node-js雪崩问题/","text":"雪崩问题的产生雪崩问题的产生是由于在计算机中的缓存存放在内存中，访问速度非常的快，常常加速数据的访问，让绝大多数的数据请求不被重复去做一些低级的数据读取。如果这时访问量大，高并发的情况下缓存容易失效，此时大量的请求同时涌入数据库中，数据库无法同时承受如此大的查询量。进而影响整个网站的额响应速度。12345var select = function (callback)&#123;db.select (\"SQL\",function(results)&#123;callback(results)&#125;)&#125; 如果站点刚刚启动，这时缓存中是不存在数据的，而访问量很大，同时执行同一句的SQL会被发送到数据库中反复查询。改进方法一：添加一个状态锁。123456789var status = \"ready\";var select = function(callback)&#123;if (status === \"ready\")&#123;status = \"pending\" ;db.select(\"SQL\",function(results)&#123; status = \"ready\";callback(results);&#125;)&#125;&#125; 但是在这种情况下会连续多次调用select( )时，只调用第一次的请求。（能不能用闭包处理此方法呢？～我也不知道，等什么时候不忙了，在研究这个问题吧～！大概想了下这个问题，感觉蛮麻烦的。）利用时间队列解决雪崩问题在订阅发布事件模式中，有一个once（）方法，通过它添加的监听器还能执行一次，执行之后，就会与实践的关联移除。这个特性可以帮我们过滤一些重复性的请求问题。123456789101112var proxy = new events.EvenEmitter();var status = \"ready\";var select = function (callback)&#123;proxy.once(\"selected\",callback);if(status === \"ready\")&#123;status = \"pending\";db.select(\"SQL\",function (results)&#123;proxy.emit(\"selected\",results);status = \"ready\";&#125;)&#125;&#125;","tags":[{"name":"node","slug":"node","permalink":"https://liuyu595.github.io/tags/node/"}]},{"title":"node.js之mongoDB数据库连接思路","date":"2017-04-05T04:35:04.000Z","path":"2017/04/05/node-js之mongoDB数据库连接思路/","text":"一入程序深似海，从此美妞儿是路人。假期三天结束了，哪里都没有去，安心在家学习充电。一切的一切：为了小钱钱～！（耿直的微微一笑）————致种花家：《那兔》 先上代码：12345678910111213141516171819202122232425var MongoClient = require('mongodb').MongoClient;var DB_CONN_STR = 'mongodb://localhost:27017/runoob';var insertData = function(db, callback) &#123;//连接到表 sitevar collection = db.collection('site');//插入数据var data = [&#123;\"name\":\"菜鸟教程\",\"url\":\"www.runoob.com\"&#125;,&#123;\"name\":\"菜鸟工具\",\"url\":\"c.runoob.com\"&#125;];collection.insert(data, function(err, result) &#123;if(err)&#123;console.log('Error:'+ err);return;&#125;callback(result);&#125;);&#125;;MongoClient.connect(DB_CONN_STR, function(err, db) &#123;console.log(\"连接成功！\");insertData(db, function(result) &#123;console.log(result);db.close();&#125;);&#125;); 如果单独执行这个命令会报错的，原因是因为没有安装依赖模块“mongodb”。 $ npm install mongodb 这个是一定要安装的。 好啦~代码分析开始： 声明一个变量引入并监听mongo模块。 声明一个变量连接本地数据库mongodb://localhost:27017/runoob。 创建回调函数。 在函数体内声明一个变量连接到表（ps:这点做了个实验，当这个表没有的时候会自己创建一个新表，然后自动插入数据）。 声明一个变量，传入数组。 监听数据库是否连接成功。","tags":[{"name":"node、数据库","slug":"node、数据库","permalink":"https://liuyu595.github.io/tags/node、数据库/"}]},{"title":"brew安装mongoDB下的坑","date":"2017-04-02T02:49:46.000Z","path":"2017/04/02/brew安装mongoDB下的坑/","text":"今天放假三天，趁此机会向着大前端迈进～！大刀阔斧～！欣喜若狂～！终于装上mongoDB了～！运行了下！启动失败了～！（有点小失落，虽然对于新的东西刚刚接触后总会出现点小问题。） MongoDB shell version v3.4.3connecting to: mongodb://127.0.0.1:270172017-04-02T10:43:39.099+0800 W NETWORK [thread1] Failed to connect to 127.0.0.1:27017, in(checking socket for error after poll), reason: Connection refused2017-04-02T10:43:39.101+0800 E QUERY [thread1] Error: couldn’t connect to server 127.0.0.1:27017, connection attempt failed :connect@src/mongo/shell/mongo.js:237:13@ (connect):1:6exception: connect failed 启动失败了，遇到这个原因纠结了一上午时间终于找到了结决的办法了。 先说下问题出现的原因：当mongodb service 没有运行的时候会发生这样的错误。最后找到了如下方法解决然后 在bash 输入 brew services start mongodbmongo //进入数据库回车后成功了～！ liuyudeMBP:~ liuyu$ mongoMongoDB shell version v3.4.3connecting to: mongodb://127.0.0.1:27017MongoDB server version: 3.4.3Welcome to the MongoDB shell.For interactive help, type “help”.For more comprehensive documentation, seehttp://docs.mongodb.org/Questions? Try the support grouphttp://groups.google.com/group/mongodb-userServer has startup warnings:2017-04-02T10:46:51.655+0800 I CONTROL [initandlisten]2017-04-02T10:46:51.655+0800 I CONTROL [initandlisten] WARNING: Access control is not enabled for the database.2017-04-02T10:46:51.655+0800 I CONTROL [initandlisten] Read and write access to data and configuration is unrestricted.2017-04-02T10:46:51.655+0800 I CONTROL [initandlisten]^Cbye","tags":[{"name":"mongoDB","slug":"mongoDB","permalink":"https://liuyu595.github.io/tags/mongoDB/"}]},{"title":"《javaScript设计模式与开发实践》（二）","date":"2017-03-30T00:58:51.000Z","path":"2017/03/30/《javaScript设计模式与开发实践》（二）/","text":"摘要：这本说写的真的不错，有食欲让我细细品味。下面来探究下call 和applyECAMScript3 给Function的原型定义了两个方法，Function.prototype.call 和Function.portotype.apply在js社基本模式中这两个方法应用非常广泛。 call和apply的区别两个方法其实作用是一样的，只是区别于传参的形式不同。apply接受两个参数，一个参数指定函数体内的this对象的指向，第二个参数为一个下标的集合，这个集合可以是数组，可以是类数组，把这个集合中的元素作为参数传递给被调用的函数。call跟上面基本一样，同样第一个参数指定this对象，第二个参数是依次传递。 锯割栗子 var func = function(a,b,c){alert( [a,b,c]); //输出 123 } func.apply( null,[1,2,3]) call和bind都有一个同样的功能就是矫正this指向问题。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://liuyu595.github.io/tags/设计模式/"}]},{"title":"鼠标拖动玩一玩","date":"2017-03-29T14:27:04.000Z","path":"2017/03/29/鼠标拖动玩一玩/","text":"摘要： 鼠标拖动封装 123456789101112131415161718192021222324252627$(function()&#123;//定义拖拽obj=$(\"#div1\");drag(obj);&#125;)function drag()&#123;obj.bind(\"mousedown\",start); //第一个是时间名 第二个是函数名function start(event)&#123; //事件触发后 产生的eventdeltaX=event.clientX-obj.offset().left;deltaY=event.clientY-obj.offset().top;$(document).bind(\"mousemove\",move);$(document).bind(\"mouseup\",stop);return false;&#125;function move()&#123;obj.css(&#123;\"left\":(event.clientX-deltaX)+\"px\",\"top\":(event.clientY-deltaY)+\"px\"&#125;)return false;&#125;function stop()&#123;$(document).unbind(\"mousemove\",move);$(document).unbind(\"mouseup\",stop);&#125;&#125;","tags":[{"name":"dome","slug":"dome","permalink":"https://liuyu595.github.io/tags/dome/"}]},{"title":"《javaScript设计模式与开发实践》（一）","date":"2017-03-29T01:05:00.000Z","path":"2017/03/29/《javaScript设计模式与开发实践》（一）/","text":"题外话：新书到了，今天试着读了下写的很不错的一本书（感谢彭彭推荐的好书）；其实很喜欢里面的一句话，程序改的越多出错的几率越大，是呀～！一点没错 第一部分面向对象的javaScript1.1动态类型语言和鸭子语言动态语言类型的优点：代码简单，看起来更简洁，但是区分不清类型的情况下会使得代码更难理解，但整体来说，代码量越少越可以多专注于逻辑。动态语言类型的缺点就是没有办法保证变量的类型。在javascript中对一个变量赋值时是不用考虑她的类型，显然javascript是一门动态语言。一切都建立在鸭子类型的基础之上，鸭子类型通俗理解就是“如果它走起路来像鸭子，叫起来也是鸭子，那么就是鸭子”，即便其中掺加入的有狗，但是狗的叫声是鸭子叫声那么他就是鸭子。1.2 多态多态的含义：同一个操作用与不同的对象上面，可以产生不同的解释和不同的执行结果。换句话说我们所写的if语句就是多态的形式。多态背后的思想就是将“做什么”和“谁去做”分离出来。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://liuyu595.github.io/tags/设计模式/"}]},{"title":"杂谈（一）","date":"2017-03-26T13:24:51.000Z","path":"2017/03/26/杂谈（一）/","text":"摘要：翻开自己的笔记本看到了这篇文章，写于2015年农历八月十五。现在回想一下也不知道是什么情况下写的了。剩下的只有莫名的伤感。正文：港囧，一部自己感觉很纠结的片子。等了20年就是为了证明我的青春岁月真实的存在过。 15岁觉得游泳难，放弃游泳，到18岁遇到一个你喜欢的人约你去游泳，你只好说“我不会耶”。18岁觉得英文难，放弃英文，28岁出现一个很棒但要会英文的工作，你只好说“我不会耶”。人生前期越嫌麻烦，越懒得学，后来就越可能错过让你动心的人和事，错过新风景。 怎样度过人生的低潮期？安静地等待；好好睡觉；锻炼身体，无论何时好的体魄都用得着；和知心的朋友谈天，基本上不发牢骚，主要是回忆快乐的时光；多读书，看一些传记，增长知识，顺带还可瞧瞧别人倒霉的时候是怎么挺过去的；趁机做家务，把平时忙碌顾不上的活儿都干完。 有时候，我们放不开不是因为失去，而是心疼自己的付出。 以前我总是习惯焦虑，每次都期望有人指明我要走的路，可人终究是孤独的，每个人的人生都有别人参与，却都要自己完成。现在我已经学会面对和接受孤独，即使伤疤没磨练的足够硬实，也不再依赖别人给的铠甲。恩，孤独的人，都会很快长大。 一座城市令你念念不忘，大抵是因为，那里有你深爱的人和一去不复返的青春。 成长的很大一部分，是接受。接受分道扬镳，接受世事无常，接受孤独挫折，接受突如其来的无力感，接受自己的缺点。然后发自内心地去改变，找到一个平衡点。跟世界相处，首先是和自己相处。天黑开盏灯，落雨带把伞，难过归难过，但也不作死。 如果你感到委屈，证明你还有底线；如果你感到迷茫，证明你还有追求；如果你感到痛苦，证明你还有力气；如果你感到绝望，证明你还有希望。从某种意义上，你永远都不会被打倒，因为你还有你。 无论贫穷还是富足，开心的人最令人羡慕。 有时像患了忧郁症一样，会突然心情不好。 偶尔像患了自闭症似的，不想说话也不想动。别人问起，也不知道该怎样回答。不是假装沉默，只是无力诉说。或许每个人都有一个死角，自己走不出来，别人也闯不进去，我把最深沉的秘密放在那里，你不懂我，我不怪你。 比起并肩、牵手、接吻、很多人最喜欢的应该还是拥抱吧。当你用双臂紧紧把一个人抱在怀里时，没什么比那更能让人体会到什么叫做拥有了。 感谢时光，不偏不倚，躲过了风口浪尖，让我恰好遇见你。","tags":[{"name":"感悟","slug":"感悟","permalink":"https://liuyu595.github.io/tags/感悟/"}]},{"title":"Three.js之小白入坑（一）","date":"2017-03-22T15:31:31.000Z","path":"2017/03/22/Three-js之小白入坑（一）/","text":"摘要：首先要感谢仙女姐姐早期发表在图灵的文章，通俗易懂，介于对这位女神的崇拜，我会认真的读下去。 正文：初识回眸一笑百媚生，六宫粉黛无颜色，初次见到是再某猫是双十二购物狂欢节的APP上，第二次见到是快过年的时候，某猫倒计时春节的一个动画。以至于一见倾心。 入坑——照相机废话不多说，带好自己的铁锹、锄头、手电筒（自己都感觉有点挖坟掘墓的节奏）。什么是照相机这个照相机值得是在图形学中的照相机，比较抽象。这里的照相机就是把三维空间头型到二维屏幕的一个方式（可以脑补下，我们在纸上画空间立体直角坐标系一样一样的）。而针对投影方式的不同，相机又分为正交投影照相机喝透视投影照相机。正交照相机蒸饺投影相机（orthogtaphic camera）设置起来比较直观哈，它的构造函数：1THREE.OrthographicCamera(left, right, top, bottom, near, far) //开头必须大写 http://wx2.sinaimg.cn/mw690/006qXO9qly1fdw1mjbntfj30jg0hkgmd.jpg 注意：为了保持照相机的横竖比例，需要保证(right - left)与(top - bottom)的比例与Canvas宽度与高度的比例一致。near与far都是指到照相机位置在深度平面的位置，而照相机不应该拍摄到其后方的物体，因此这两个值应该均为正值。为了保证场景中的物体不会因为太近或太远而被照相机忽略，一般near的值设置得较小，far的值设置得较大，具体值视场景中物体的位置等决定。下面是关键词，当在有问题需要查帮助文档时 直接搜索关键词：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189Cameras（照相机，控制投影方式）CameraOrthographicCameraPerspectiveCameraCore（核心对象）BufferGeometryClock（用来记录时间）EventDispatcherFace3Face4GeometryObject3DProjectorRaycaster（计算鼠标拾取物体时很有用的对象）Lights（光照）LightAmbientLightAreaLightDirectionalLightHemisphereLightPointLightSpotLightLoaders（加载器，用来加载特定文件）LoaderBinaryLoaderGeometryLoaderImageLoaderJSONLoaderLoadingMonitorSceneLoaderTextureLoaderMaterials（材质，控制物体的颜色、纹理等）MaterialLineBasicMaterialLineDashedMaterialMeshBasicMaterialMeshDepthMaterialMeshFaceMaterialMeshLambertMaterialMeshNormalMaterialMeshPhongMaterialParticleBasicMaterialParticleCanvasMaterialParticleDOMMaterialShaderMaterialSpriteMaterialMath（和数学相关的对象）Box2Box3ColorFrustumMathMatrix3Matrix4PlaneQuaternionRaySphereSplineTriangleVector2Vector3Vector4Objects（物体）BoneLineLODMesh（网格，最常用的物体）MorphAnimMeshParticleParticleSystemRibbonSkinnedMeshSpriteRenderers（渲染器，可以渲染到不同对象上）CanvasRendererWebGLRenderer（使用WebGL渲染，这是本书中最常用的方式）WebGLRenderTargetWebGLRenderTargetCubeWebGLShaders（着色器，在最后一章作介绍）Renderers / RenderablesRenderableFace3RenderableFace4RenderableLineRenderableObjectRenderableParticleRenderableVertexScenes（场景）FogFogExp2SceneTextures（纹理）CompressedTextureDataTextureTextureExtrasFontUtilsGeometryUtilsImageUtilsSceneUtilsExtras / AnimationAnimationAnimationHandlerAnimationMorphTargetKeyFrameAnimationExtras / CamerasCombinedCameraCubeCameraExtras / CoreCurveCurvePathGyroscopePathShapeExtras / Geometries（几何形状）CircleGeometryConvexGeometryCubeGeometryCylinderGeometryExtrudeGeometryIcosahedronGeometryLatheGeometryOctahedronGeometryParametricGeometryPlaneGeometryPolyhedronGeometryShapeGeometrySphereGeometryTetrahedronGeometryTextGeometryTorusGeometryTorusKnotGeometryTubeGeometryExtras / HelpersArrowHelperAxisHelperCameraHelperDirectionalLightHelperHemisphereLightHelperPointLightHelperSpotLightHelperExtras / ObjectsImmediateRenderObjectLensFlareMorphBlendMeshExtras / Renderers / PluginsDepthPassPluginLensFlarePluginShadowMapPluginSpritePluginExtras / ShadersShaderFlaresShaderSprite 透视相机透视相机参数的构造函数： THREE.PerspectiveCamera(fov, aspect, near, far)透视图中，灰色的部分是视景体，是可能被渲染的物体所在的区域。fov是视景体竖直方向上的张角（是角度制而非弧度制），如侧视图所示。 aspect等于width / height，是照相机水平方向和竖直方向长度的比值，通常设为Canvas的横纵比例。 near和far分别是照相机到视景体最近、最远的距离，均为正值，且far应大于near。","tags":[{"name":"Three.js","slug":"Three-js","permalink":"https://liuyu595.github.io/tags/Three-js/"}]},{"title":"ES6入门笔记（四）","date":"2017-03-19T15:17:52.000Z","path":"2017/03/19/ES6入门笔记（四）/","text":"摘要：Promise 正文： Promise:——承诺这是个什么鬼？大概看了下往上对于这个东西神话已经的评论！看来面对这个东西是一场硬仗～！感觉到了千军万马，只有我只身一人～！只待我上阵杀敌挥起大刀砍杀时，说时迟那时快，手起刀落才知道——尼玛他就是个Promise对象。这个对象主要来传递异步操作的数据（消息），这个对象规定了三种状态： pending(等待／处理中)—&gt;Resolve(完成／fullfilled)—&gt;rejected(拒绝／失败)这样的处理方式能使得ajax异步请求更加的完美；","tags":[{"name":"ES6","slug":"ES6","permalink":"https://liuyu595.github.io/tags/ES6/"}]},{"title":"ES6Tab选项卡、轮播图","date":"2017-03-15T14:27:07.000Z","path":"2017/03/15/ES6Tab选项卡、轮播图/","text":"摘要：ES6 面向对象编程——选项卡、轮播图 正文： es6面向对象——选项卡、轮播直接荔枝（今天心情不错，换个果子） 样式部分 1234567.on&#123;background:#f60;color:#fff&#125;.box div&#123;width:200px;height:200px;border:1px red solid;display:none;&#125; heml部分12345678910111213141516&lt;div id=\"box\" class=\"box\"&gt;&lt;input class=\"on\" type=\"button\" value=\"aaa\"&gt;&lt;input type=\"button\" value=\"bbb\"&gt;&lt;input type=\"button\" value=\"ccc\"&gt;&lt;div style=\"display: block\"&gt;111&lt;/div&gt;&lt;div&gt;222&lt;/div&gt;&lt;div&gt;333&lt;/div&gt;&lt;/div&gt;&lt;div id=\"box2\" class=\"box\"&gt;&lt;input class=\"on\" type=\"button\" value=\"aaa\"&gt;&lt;input type=\"button\" value=\"bbb\"&gt;&lt;input type=\"button\" value=\"ccc\"&gt;&lt;div style=\"display: block\"&gt;111&lt;/div&gt;&lt;div&gt;222&lt;/div&gt;&lt;div&gt;333&lt;/div&gt;&lt;/div&gt; js部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Tab&#123;constructor(id)&#123;this.oBox=document.getElementById(id);this.aBtn=this.oBox.getElementsByTagName('input');this.aDiv=this.oBox.getElementsByTagName('div');this.iNow=0;this.init();&#125;init()&#123;for(let i=0; i&lt;this.aBtn.length; i++)&#123;this.aBtn[i].onclick=function()&#123;// alert(i);// alert(this);this.hide();this.show(i);&#125;.bind(this); //bind矫正this指向&#125;&#125;hide()&#123;for(let i=0;i&lt;this.aBtn.length;i++)&#123;this.aBtn[i].className=\"\";this.aDiv[i].style.display='none';&#125;&#125;show(index)&#123;this.aBtn[index].className=\"on\";this.aDiv[index].style.display='block';&#125;&#125;//继承class AutoTab extends Tab&#123;//constructor(id)&#123;super(id);//alert(111);//setInterval(this.next,1000); this 指向objsetInterval(this.next.bind(this),1000);&#125;next()&#123;this.iNow++;if(this.iNow==this.aBtn.length)this.iNow=0;this.hide();this.show(this.iNow);&#125;&#125;window.onload=function()&#123;new Tab('box');var at=new AutoTab(\"box2\");&#125;","tags":[{"name":"ES6语法","slug":"ES6语法","permalink":"https://liuyu595.github.io/tags/ES6语法/"}]},{"title":"ES6入门笔记（三）","date":"2017-03-14T06:17:47.000Z","path":"2017/03/14/ES6入门笔记（三）“/","text":"摘要：箭头函数、面向对象、继承。 正文： 箭头函数 =&gt;不多说直接一个栗子：12345678window.onload=()=&gt;&#123;var oBox=document.getElementById(\"box\");oBox.onclivk=()=&gt;&#123;//alert(this);//这时这里的this指的是window,所有没有办法this.styleoBox.style.background=\"red\";&#125;;&#125;; 1&lt;div id=\"box\"&gt;&lt;/div&gt; 注意：1、 this的问题,指向window；2、箭头函数中arguments,不能使用。 对象：es6对象作了简化单体模式直接简单粗暴上举板栗： 12345678910111213var name='abb';var age=111;var preson=&#123;name,age,showName()&#123;return this.name;&#125;,showName()&#123;return this.age;&#125;&#125;;alert( preson.showName() ); 面向对象es6之前123456789101112function Person(name,age)&#123;this.name=name;this.age=age;&#125;Person.prototype.showName=function()&#123;return this.name;&#125;;Person.prototype.showName=function()&#123;return this.name;&#125;;var p1=new Person(\"abc\",101);alert(p1.showName()); 上面这样写不是真的面向对象，这里的这个东西又是类又是构造函数。es6在面向对象上面做了一个彻底的区分，什么是构造函数？构造函数简单的说就是生成实例以后，自己就执行的函数。1234567891011121314151617来吧～！锯割栗子：```javascriptclass Person&#123; //类constructor(name,age)&#123;this.name=name;this.age=age;&#125;showName()&#123;return this.name;&#125;showAge()&#123;return this.age;&#125;&#125; 函数给默认值1234function move(obj=\"对象必须要填写\"，json=&#123;&#125;)&#123;console.log(options);&#125;move(); 继承之前的继承，来再锯割栗子：1234567function Worker(name,age)&#123;Person.apply(this,arguments);&#125;Worker.prototype=new Person();var w1=new Person('ddd',20);alert(p1.showName());//之前的继承模式：子类.prptotype=new 父类（）； es6中的继承123456789function Worker(name,age)&#123;Person.apply(this,arguments);&#125;//继承开始class Worker extends Person&#123;&#125;var w1=new Worker('mmm',34);alert(w1.showAge()); //34 es6继承中的super锯割栗子：（今天晚上很暴力的吃了好的坚果）1234567891011121314151617181920212223242526class Person&#123;constructor(name='add',age=0)&#123;this.name=name;this.age=age;&#125;showName()&#123;return this.name;&#125;showAge()&#123;return this.age;&#125; &#125;//继承开始class Worker extends Person&#123;constructor(name,age,job=\"刷马桶\")&#123;//这样写之后，之前的父级的构造函数被覆盖掉了为了不被覆盖掉那么我们就用super.//this.job=job; //definedsuper(name,age);this.job=job&#125;showJob()&#123;return this.job;&#125;&#125;var w1=new Worker('mmm',34); 每天多学一点，明天就少写一行代码～！","tags":[{"name":"ES6语法","slug":"ES6语法","permalink":"https://liuyu595.github.io/tags/ES6语法/"}]},{"title":"hexo之入门后填坑(一)","date":"2017-03-13T01:26:51.000Z","path":"2017/03/13/hexo之入门后填坑（一）/","text":"摘要：本文主要说下markdown的语法，编译器。 正文:对于一个新手小白，真的是一坑到底的节奏了。欲哭无泪跳坑吧～！科普下吧：Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 代码块 +「脚本语言名称全拼」+代码内容+```结束12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 表格语法格式12345| Item | Value | Qty || :-------- | --------:| :--: || Computer | 1600 USD | 5 || Phone | 12 USD | 12 || Pipe | 1 USD | 234 | ``` markdown编译器： 推荐 sublime :轻量级编译器功能强大，不具有实时显示编辑文本功能。不建议新手使用。 推荐 马克飞象 :之前一直用印象笔记去记录代码总结，马克飞象是支持Chrome的同样可以绑定到印象笔记，具备实时编辑文本功能。推荐新手使用。","tags":[{"name":"hexo","slug":"hexo","permalink":"https://liuyu595.github.io/tags/hexo/"}]},{"title":"ES6入门笔记（二）","date":"2017-03-12T06:17:47.000Z","path":"2017/03/12/ES6入门笔记（二）/","text":"摘要： 复制数组————spread、Map、for-of循环 正文： 数组复制 举栗子 12345var arr = [1,2,3];var arr2=arr;arr2.pop();console.log(arr, arr2);//arr2删除最后一个元素时，arr也会受到影响 怎么才能不让我们的arr受到牵连呢？ 再举一栗子—–循环 1234567var arr = [1,2,3];var arr2=[];for(var i=0; i&lt;arr.length; i++)&#123;arr2[i]=arr[i];&#125;console.log(arr, arr2);//arr这时候是不会受到任何影响的；但是这种方法比较繁琐； 下面在举一个板栗吧～！ 12345var arr = [1,2,3];var arr2=Array.from(arr);arr2.pop();console.log(arr, arr2);//这个板栗还是可以的，简单多了； 科普下Array.from( ) es6 新特性中 Array 类多了一个静态方法 from ，这个方法作用是将一个 ArrayLike 对象或者 Iterable 对象转换成一个 Array。所谓 ArrayLike 对象指具有数组某些行为的对象，表现出来的特征就是具有 length 属性。 1234var obj = &#123;\"0\" : 1,length: 1&#125;; 这一类对象不能调用数组所具有的方法(push/forEach/map之类)，最常见的有两种：DOM中的 NodeList 和函数中的 arguments 。在平常开发中，我们经常遇到需要将这两种对象转化为真正数组的场景，一般我们是这么写： 12var args = [].slice.call(arguments);var imgs = [].slice.call(document.querySelectorAll('img')); 现在有了Array.from后我们可以这样写： 123var args = Array.from(arguments);var imgs = Array.from(document.querySelectorAll('img'));//不考虑兼容性的时候我们可以这样写 下面言归正传吧：接着写我们的数组～接着举例子！ 新鲜板栗来了～！好吃不贵1234var arr = [1,2,3];var arr2=[...arr];arr2.pop();//前面的这三个点——“超引用”这么叫吧 123456function show(...args)&#123;args.push(5);console.log(args);&#125;show(1,2,3,4)//完美解决 ##循环 es6新增了一个 for of 循环，那么这个循环的目的：是遍历（迭代、循环）这个对象，表现有点类似for in。但是不能循环json,其真正的目的是循环 map对象的。 来个代码看看吧1234var arr=['apple','banana','orange','pear'];for(var i of arr)&#123;console.log(i);&#125; 注：上述打印出来的结果跟普通的for in 打印出来的结果不一样，for in打印出来是数组的下标，而for of 打印出来却是相对应的水果名字。 Map对象map对象和json相似，也是一种key-value形式，Map对象为了和for of 循环为何而生。 语法123456789101112131415var map =new Map（）；//设置：map.set(name,value);//获取map.set('a','apple');map.set('b','banana');//console.log(map.a);//alert(map.a); undefined//获取map就用get（）方法alert(map.get('a'))//删除delete map.a; //json 删除方法在这里没有效果map.delete('a'); //map的delete方法，可以用的 map和for of结合去用：123456789var map =new Map();map.set('a','apple');map.set('b','banana');map.set('c','orange');map.set('d','pear');for(var [key,value] of map)&#123;console.log(key,value);//[key,value]中两个参数可以是任何字母&#125; 1234for(var [key,value] of map)&#123;console.log(key,value);//这时map的默认值是enteries,也就是map.enteries( ),&#125; 单独获取a b c d 12345678910var map =new Map();map.set('a','apple');map.set('b','banana');map.set('c','orange');map.set('d','pear');for(var key of map.keys())&#123;console.log(key);&#125;//循环val 同理","tags":[{"name":"ES6语法","slug":"ES6语法","permalink":"https://liuyu595.github.io/tags/ES6语法/"}]},{"title":"”ES6入门笔记（一）“","date":"2017-03-12T03:03:33.000Z","path":"2017/03/12/ES6入门笔记（一）“/","text":"摘要： 之前我们接触到的js主要是由ECMA DOM BOM组成的。ES6就是之前的一个版本的迭代。 ECMA是标准，JS是实现者；换句话说还有可能有其他的版本来实现ECMA. 目前浏览器：主要分为两种一个是高级低级浏览器：主要支持ES3.1;高级浏览器正在从ES5到ES6过度。 正文: 直接在node里面使用： 1.直接用，需要在相应的js文件中头部添加‘ues strict’; 2.nede –harmony_destructuring xxx.js; 定义变量——let(目前位置已经被浏览器支持，不用引入js)； 代码块：{}包起来的代码叫代码块； 例如：{ let a=12; alert(a); //是可以在浏览器中拿到的 } alert(a)//这里的这个a 在浏览器中是不能被拿到的。 所以用{}包起来后就形成了一个作用域，这个作用域之能在相应的块中实现； let 声明的变量与 var声明的变量不同的是，var只有在函数体中才有作用域，而let与此不同； 封闭空间的问题： 之前用var声明一个变量的时候： for(var i=; i&lt;aBtn.length; i++){ (function(i){ aBtn[i].onclick=function(){ alert(i); } })(i); }; // 这样写的原因是var 没有一个封闭空间所以要用一个自运行函数在包裹它； 那么现在的let 是什么样子呢？for(let i=0; i&lt;aBtn.length;i++){ aBtn[i].onclick=function(){ alert(i);} 如果出现了一个大组件怎么办呢？怎么办呢？怎么办呢～！逗比呢？不是有const来定义敞亮么？常量一旦赋值就没有办法再修改了呀～！ ———————————————————————————————— 下面说下字符串链接：（个人感觉没有什么区别，估计是之前用习惯了吧） 反单引号 字符串模版 ： var str=`` 这两个单引号就是 数字1键前面的那个东西～ ·阿斯顿$(变量名)风格化` ———————————————————————————————— 解构赋值：var [a,b,c]=[12,3,5] 那么json的解构赋值就是：var {a,b,c}={a:2,b:3,c:3}; 注意：解构赋值时 要对应名字～！！！！切记～切记～！ 模式匹配：——————左边和右边的样式一样 var [a,[b,c],d]=[12,[1,2],5]; 此外补充一点解构赋值是可以给默认值的： 语法：var {time=12,id=0}={} 然而之前的方法是这样的：var json={}; var a=json.a||12 今天就到此为止吧～ 还是那句话，每天多学一点，就能少打一行代码～！","tags":[{"name":"ES6语法","slug":"ES6语法","permalink":"https://liuyu595.github.io/tags/ES6语法/"}]},{"title":"放眼看世界","date":"2017-03-09T03:42:59.000Z","path":"2017/03/09/see-word/","text":"摘要： 测试第一个博客文章正文：走自己的路，让别人羡慕","tags":[{"name":"放眼看世界 世界都亮了","slug":"放眼看世界-世界都亮了","permalink":"https://liuyu595.github.io/tags/放眼看世界-世界都亮了/"}]},{"title":"Hello World","date":"2017-03-09T02:49:02.000Z","path":"2017/03/09/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]